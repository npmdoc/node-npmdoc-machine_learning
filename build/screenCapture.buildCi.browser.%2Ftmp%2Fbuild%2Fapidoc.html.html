<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://joonku.com/project/machine_learning">machine_learning (v0.1.1)</a>
</h1>
<h4>Machine learning library for Node.js. You can also use this library in browser.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning">module machine_learning</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.DecisionTree">
            function <span class="apidocSignatureSpan">machine_learning.</span>DecisionTree
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.HiddenLayer">
            function <span class="apidocSignatureSpan">machine_learning.</span>HiddenLayer
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.KNN">
            function <span class="apidocSignatureSpan">machine_learning.</span>KNN
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.LogisticRegression">
            function <span class="apidocSignatureSpan">machine_learning.</span>LogisticRegression
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.MLP">
            function <span class="apidocSignatureSpan">machine_learning.</span>MLP
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.SVM">
            function <span class="apidocSignatureSpan">machine_learning.</span>SVM
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.</span>DecisionTree.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.</span>HiddenLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.</span>KNN.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.</span>LogisticRegression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.</span>MLP.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.</span>SVM.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.</span>kmeans</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.</span>math</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.</span>nmf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.</span>optimize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.DecisionTree">module machine_learning.DecisionTree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.DecisionTree.DecisionTree">
            function <span class="apidocSignatureSpan">machine_learning.</span>DecisionTree
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.DecisionTree.prototype">module machine_learning.DecisionTree.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.DecisionTree.prototype.build">
            function <span class="apidocSignatureSpan">machine_learning.DecisionTree.prototype.</span>build
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.DecisionTree.prototype.classify">
            function <span class="apidocSignatureSpan">machine_learning.DecisionTree.prototype.</span>classify
            <span class="apidocSignatureSpan">(observation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.DecisionTree.prototype.getTree">
            function <span class="apidocSignatureSpan">machine_learning.DecisionTree.prototype.</span>getTree
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.DecisionTree.prototype.print">
            function <span class="apidocSignatureSpan">machine_learning.DecisionTree.prototype.</span>print
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.DecisionTree.prototype.prune">
            function <span class="apidocSignatureSpan">machine_learning.DecisionTree.prototype.</span>prune
            <span class="apidocSignatureSpan">(mingain)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.HiddenLayer">module machine_learning.HiddenLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.HiddenLayer.HiddenLayer">
            function <span class="apidocSignatureSpan">machine_learning.</span>HiddenLayer
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.HiddenLayer.prototype">module machine_learning.HiddenLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.HiddenLayer.prototype.backPropagate">
            function <span class="apidocSignatureSpan">machine_learning.HiddenLayer.prototype.</span>backPropagate
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.HiddenLayer.prototype.linearOutput">
            function <span class="apidocSignatureSpan">machine_learning.HiddenLayer.prototype.</span>linearOutput
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.HiddenLayer.prototype.output">
            function <span class="apidocSignatureSpan">machine_learning.HiddenLayer.prototype.</span>output
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.HiddenLayer.prototype.sampleHgivenV">
            function <span class="apidocSignatureSpan">machine_learning.HiddenLayer.prototype.</span>sampleHgivenV
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.KNN">module machine_learning.KNN</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.KNN.KNN">
            function <span class="apidocSignatureSpan">machine_learning.</span>KNN
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.KNN.prototype">module machine_learning.KNN.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.KNN.prototype.predict">
            function <span class="apidocSignatureSpan">machine_learning.KNN.prototype.</span>predict
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.LogisticRegression">module machine_learning.LogisticRegression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.LogisticRegression.LogisticRegression">
            function <span class="apidocSignatureSpan">machine_learning.</span>LogisticRegression
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.LogisticRegression.prototype">module machine_learning.LogisticRegression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.LogisticRegression.prototype.getReconstructionCrossEntropy">
            function <span class="apidocSignatureSpan">machine_learning.LogisticRegression.prototype.</span>getReconstructionCrossEntropy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.LogisticRegression.prototype.predict">
            function <span class="apidocSignatureSpan">machine_learning.LogisticRegression.prototype.</span>predict
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.LogisticRegression.prototype.set">
            function <span class="apidocSignatureSpan">machine_learning.LogisticRegression.prototype.</span>set
            <span class="apidocSignatureSpan">(property, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.LogisticRegression.prototype.train">
            function <span class="apidocSignatureSpan">machine_learning.LogisticRegression.prototype.</span>train
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.MLP">module machine_learning.MLP</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.MLP.MLP">
            function <span class="apidocSignatureSpan">machine_learning.</span>MLP
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.MLP.prototype">module machine_learning.MLP.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.MLP.prototype.getReconstructionCrossEntropy">
            function <span class="apidocSignatureSpan">machine_learning.MLP.prototype.</span>getReconstructionCrossEntropy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.MLP.prototype.predict">
            function <span class="apidocSignatureSpan">machine_learning.MLP.prototype.</span>predict
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.MLP.prototype.set">
            function <span class="apidocSignatureSpan">machine_learning.MLP.prototype.</span>set
            <span class="apidocSignatureSpan">(property, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.MLP.prototype.train">
            function <span class="apidocSignatureSpan">machine_learning.MLP.prototype.</span>train
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.SVM">module machine_learning.SVM</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.SVM.SVM">
            function <span class="apidocSignatureSpan">machine_learning.</span>SVM
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.SVM.prototype">module machine_learning.SVM.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.SVM.prototype.f">
            function <span class="apidocSignatureSpan">machine_learning.SVM.prototype.</span>f
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.SVM.prototype.predict">
            function <span class="apidocSignatureSpan">machine_learning.SVM.prototype.</span>predict
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.SVM.prototype.train">
            function <span class="apidocSignatureSpan">machine_learning.SVM.prototype.</span>train
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.kmeans">module machine_learning.kmeans</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.kmeans.cluster">
            function <span class="apidocSignatureSpan">machine_learning.kmeans.</span>cluster
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.math">module machine_learning.math</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.activateMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>activateMat
            <span class="apidocSignatureSpan">(mat, activation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.activateTwoMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>activateTwoMat
            <span class="apidocSignatureSpan">(mat1, mat2, activation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.activateTwoVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>activateTwoVec
            <span class="apidocSignatureSpan">(vec1, vec2, activation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.activateVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>activateVec
            <span class="apidocSignatureSpan">(vec, activation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.addMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>addMat
            <span class="apidocSignatureSpan">(mat1, mat2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.addMatScalar">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>addMatScalar
            <span class="apidocSignatureSpan">(mat, scalar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.addMatVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>addMatVec
            <span class="apidocSignatureSpan">(mat, vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.addVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>addVec
            <span class="apidocSignatureSpan">(vec1, vec2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.covarianceVecs">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>covarianceVecs
            <span class="apidocSignatureSpan">(vecs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.dSigmoid">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>dSigmoid
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.dotVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>dotVec
            <span class="apidocSignatureSpan">(vec1, vec2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.euclidean">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>euclidean
            <span class="apidocSignatureSpan">(x1, x2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.fillMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>fillMat
            <span class="apidocSignatureSpan">(row, col, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.fillVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>fillVec
            <span class="apidocSignatureSpan">(n, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.gaussian">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>gaussian
            <span class="apidocSignatureSpan">(x, sigma)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.getNormVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>getNormVec
            <span class="apidocSignatureSpan">(vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.identity">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>identity
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.maxMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>maxMat
            <span class="apidocSignatureSpan">(mat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.maxVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>maxVec
            <span class="apidocSignatureSpan">(vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.meanMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>meanMat
            <span class="apidocSignatureSpan">(mat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.meanMatAxis">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>meanMatAxis
            <span class="apidocSignatureSpan">(mat, axis)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.meanVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>meanVec
            <span class="apidocSignatureSpan">(vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.meanVecs">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>meanVecs
            <span class="apidocSignatureSpan">(vecs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.minMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>minMat
            <span class="apidocSignatureSpan">(mat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.minVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>minVec
            <span class="apidocSignatureSpan">(vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.minusMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>minusMat
            <span class="apidocSignatureSpan">(mat1, mat2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.minusMatVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>minusMatVec
            <span class="apidocSignatureSpan">(mat, vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.minusVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>minusVec
            <span class="apidocSignatureSpan">(vec1, vec2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.mulMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>mulMat
            <span class="apidocSignatureSpan">(mat1, mat2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.mulMatElementWise">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>mulMatElementWise
            <span class="apidocSignatureSpan">(mat1, mat2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.mulMatScalar">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>mulMatScalar
            <span class="apidocSignatureSpan">(mat, scalar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.mulVecScalar">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>mulVecScalar
            <span class="apidocSignatureSpan">(vec, scalar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.normalizeVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>normalizeVec
            <span class="apidocSignatureSpan">(vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.oneMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>oneMat
            <span class="apidocSignatureSpan">(row, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.oneVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>oneVec
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.outerVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>outerVec
            <span class="apidocSignatureSpan">(vec1, vec2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.pearson">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>pearson
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.probToBinaryMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>probToBinaryMat
            <span class="apidocSignatureSpan">(mat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.randInt">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>randInt
            <span class="apidocSignatureSpan">(min, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.randMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>randMat
            <span class="apidocSignatureSpan">(row, col, lower, upper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.randVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>randVec
            <span class="apidocSignatureSpan">(n, lower, upper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.randn">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>randn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.randnMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>randnMat
            <span class="apidocSignatureSpan">(row, col, mean, sigma)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.randnVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>randnVec
            <span class="apidocSignatureSpan">(n, mean, sigma)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.range">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>range
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.shape">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>shape
            <span class="apidocSignatureSpan">(mat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.shuffle">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>shuffle
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.sigmoid">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>sigmoid
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.softmaxMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>softmaxMat
            <span class="apidocSignatureSpan">(mat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.softmaxVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>softmaxVec
            <span class="apidocSignatureSpan">(vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.squareMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>squareMat
            <span class="apidocSignatureSpan">(mat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.squareVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>squareVec
            <span class="apidocSignatureSpan">(vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.sumMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>sumMat
            <span class="apidocSignatureSpan">(mat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.sumMatAxis">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>sumMatAxis
            <span class="apidocSignatureSpan">(mat, axis)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.sumVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>sumVec
            <span class="apidocSignatureSpan">(vec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.transpose">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>transpose
            <span class="apidocSignatureSpan">(mat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.zeroMat">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>zeroMat
            <span class="apidocSignatureSpan">(row, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.math.zeroVec">
            function <span class="apidocSignatureSpan">machine_learning.math.</span>zeroVec
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.nmf">module machine_learning.nmf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.nmf.factorize">
            function <span class="apidocSignatureSpan">machine_learning.nmf.</span>factorize
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.optimize">module machine_learning.optimize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.optimize.anneal">
            function <span class="apidocSignatureSpan">machine_learning.optimize.</span>anneal
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.optimize.genetic">
            function <span class="apidocSignatureSpan">machine_learning.optimize.</span>genetic
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.optimize.hillclimb">
            function <span class="apidocSignatureSpan">machine_learning.optimize.</span>hillclimb
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.machine_learning.utils">module machine_learning.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.machine_learning.utils.isNumber">
            function <span class="apidocSignatureSpan">machine_learning.utils.</span>isNumber
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">machine_learning.utils.</span>math</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning" id="apidoc.module.machine_learning">module machine_learning</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.DecisionTree" id="apidoc.element.machine_learning.DecisionTree">
        function <span class="apidocSignatureSpan">machine_learning.</span>DecisionTree
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DecisionTree = function (options) {
    var self = this;
    self.data = options['data'];
    self.result = options['result'];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           ['kiwitobes','UK','no',19],
           ['digg','New Zealand','yes',12],
           ['slashdot','UK','no',21],
           ['google','UK','yes',18],
           ['kiwitobes','France','yes',19]];
var result = ['None','Premium','Basic','Basic','Premium','None','
;Basic','Premium','None','None','None','None','Basic','None
','Basic','Basic'];

var dt = new ml.<span class="apidocCodeKeywordSpan">DecisionTree</span>({
    data : data,
    result : result
});

dt.build();

// dt.print();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.HiddenLayer" id="apidoc.element.machine_learning.HiddenLayer">
        function <span class="apidocSignatureSpan">machine_learning.</span>HiddenLayer
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HiddenLayer = function (settings) {
    var self = this;
    self.input = settings['input'];

    if(typeof settings['W'] === 'undefined') {
        var a = 1. / settings['n_in'];
        settings['W'] = math.randMat(settings['n_in'],settings['n_out'],-a,a);
    }
    if(typeof settings['b'] === 'undefined')
        settings['b'] = math.zeroVec(settings['n_out']);
    if(typeof settings['activation'] === 'undefined')
        settings['activation'] = math.sigmoid;

    self.W = settings['W'];
    self.b = settings['b'];
    self.activation = settings['activation'];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.KNN" id="apidoc.element.machine_learning.KNN">
        function <span class="apidocSignatureSpan">machine_learning.</span>KNN
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KNN = function (options) {
    var self = this;
    self.data = options['data'];
    self.result = options['result'];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        [0,0,1,0,1,0,1,1,1,1,0,1,1,1],
        [0,0,0,0,0,0,1,1,1,1,1,1,1,1],
        [1,0,1,0,0,1,1,1,1,1,0,0,1,0]
       ];

var result = [23,12,23,23,45,70,123,73,146,158,64];

var knn = new ml.<span class="apidocCodeKeywordSpan">KNN</span>({
data : data,
result : result
});

var y = knn.predict({
x : [0,0,0,0,0,0,0,1,1,1,1,1,1,1],
k : 3,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.LogisticRegression" id="apidoc.element.machine_learning.LogisticRegression">
        function <span class="apidocSignatureSpan">machine_learning.</span>LogisticRegression
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LogisticRegression = function (settings) {
    var self = this;
    self.x = settings['input'];
    self.y = settings['label'];
    self.W = math.zeroMat(settings['n_in'],settings['n_out']);
    self.b = math.zeroVec(settings['n_out']);
    self.settings = {
        'log level' : 1 // 0 : nothing, 1 : info, 2: warn
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var y = [[1, 0],
         [1, 0],
         [1, 0],
         [0, 1],
         [0, 1],
         [0, 1]];

var classifier = new ml.<span class="apidocCodeKeywordSpan">LogisticRegression</span>({
    'input' : x,
    'label' : y,
    'n_in' : 6,
    'n_out' : 2
});

classifier.set('log level',1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.MLP" id="apidoc.element.machine_learning.MLP">
        function <span class="apidocSignatureSpan">machine_learning.</span>MLP
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MLP = function (settings) {
    var self = this;
    self.x = settings['input'];
    self.y = settings['label'];
    self.sigmoidLayers = [];
    self.nLayers = settings['hidden_layer_sizes'].length;
    self.settings = {
        'log level' : 1 // 0 : nothing, 1 : info, 2: warn
    };
    var i;
    for(i=0 ; i&lt;self.nLayers+1 ; i++) {
        var inputSize, layerInput;
        if(i == 0)
            inputSize = settings['n_ins'];
        else
            inputSize = settings['hidden_layer_sizes'][i-1];

        if(i == 0)
            layerInput = self.x;
        else
            layerInput = self.sigmoidLayers[self.sigmoidLayers.length-1].sampleHgivenV();

        var sigmoidLayer;
        if(i == self.nLayers) {
            sigmoidLayer = new HiddenLayer({
                'input' : layerInput,
                'n_in' : inputSize,
                'n_out' : settings['n_outs'],
                'activation' : math.sigmoid,
                'W' : (typeof settings['w_array'] === 'undefined')? undefined : settings['w_array'][i],
                'b' : (typeof settings['b_array'] === 'undefined')? undefined : settings['b_array'][i]
            });
        } else {
            sigmoidLayer = new HiddenLayer({
                'input' : layerInput,
                'n_in' : inputSize,
                'n_out' : settings['hidden_layer_sizes'][i],
                'activation' : math.sigmoid,
                'W' : (typeof settings['w_array'] === 'undefined')? undefined : settings['w_array'][i],
                'b' : (typeof settings['b_array'] === 'undefined')? undefined : settings['b_array'][i]
            });
        }
        self.sigmoidLayers.push(sigmoidLayer);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var y = [[1, 0],
         [1, 0],
         [1, 0],
         [0, 1],
         [0, 1],
         [0, 1]];

var mlp = new ml.<span class="apidocCodeKeywordSpan">MLP</span>({
    'input' : x,
    'label' : y,
    'n_ins' : 6,
    'n_outs' : 2,
    'hidden_layer_sizes' : [4,4,5]
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.SVM" id="apidoc.element.machine_learning.SVM">
        function <span class="apidocSignatureSpan">machine_learning.</span>SVM
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SVM = function (options) {
    var self = this;
    self.x = options['x'];
    self.y = options['y'];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     [0.2, 0.01, 0.5, 0.,  0.,  0.9],
     [0.,  0.,  0.5, 0.3, 0.5, -2.3],
     [0.,  0.,  0.5, 0.4, 0.5, 4],
     [0.,  0.,  0.5, 0.5, 0.5, -2]];

var y =  [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,1,1];

var svm = new ml.<span class="apidocCodeKeywordSpan">SVM</span>({
x : x,
y : y
});

svm.train({
C : 1.1, // default : 1.0. C in SVM.
tol : 1e-5, // default : 1e-4. Higher tolerance --&gt; Higher precision
...</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.DecisionTree" id="apidoc.module.machine_learning.DecisionTree">module machine_learning.DecisionTree</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.DecisionTree.DecisionTree" id="apidoc.element.machine_learning.DecisionTree.DecisionTree">
        function <span class="apidocSignatureSpan">machine_learning.</span>DecisionTree
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DecisionTree = function (options) {
    var self = this;
    self.data = options['data'];
    self.result = options['result'];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           ['kiwitobes','UK','no',19],
           ['digg','New Zealand','yes',12],
           ['slashdot','UK','no',21],
           ['google','UK','yes',18],
           ['kiwitobes','France','yes',19]];
var result = ['None','Premium','Basic','Basic','Premium','None','
;Basic','Premium','None','None','None','None','Basic','None
','Basic','Basic'];

var dt = new ml.<span class="apidocCodeKeywordSpan">DecisionTree</span>({
    data : data,
    result : result
});

dt.build();

// dt.print();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.DecisionTree.prototype" id="apidoc.module.machine_learning.DecisionTree.prototype">module machine_learning.DecisionTree.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.DecisionTree.prototype.build" id="apidoc.element.machine_learning.DecisionTree.prototype.build">
        function <span class="apidocSignatureSpan">machine_learning.DecisionTree.prototype.</span>build
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function (options) {
    var self = this;
    var rows = [];
    var i;
    for(i=0; i&lt;self.data.length; i++) {
        rows.push(self.data[i]);
        rows[i].push(self.result[i]);
    }
    self.tree = buildTree(rows,entropy);
    return self.tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var result = ['None','Premium','Basic','Basic','Premium','None','
;Basic','Premium','None','None','None','None','Basic','None
','Basic','Basic'];

var dt = new ml.DecisionTree({
    data : data,
    result : result
});

dt.<span class="apidocCodeKeywordSpan">build</span>();

// dt.print();

console.log("Classify : ", dt.classify(['(direct)','USA','yes',5]));

dt.prune(1.0); // 1.0 : mingain.
dt.print();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.DecisionTree.prototype.classify" id="apidoc.element.machine_learning.DecisionTree.prototype.classify">
        function <span class="apidocSignatureSpan">machine_learning.DecisionTree.prototype.</span>classify
        <span class="apidocSignatureSpan">(observation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classify = function (observation) {
    var self = this;
    return classify(observation,self.tree);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    result : result
});

dt.build();

// dt.print();

console.log("Classify : ", dt.<span class="apidocCodeKeywordSpan">classify</span>(['(direct)','USA'
;,'yes',5]));

dt.prune(1.0); // 1.0 : mingain.
dt.print();
```

## NMF (Non-negative matrix factorization)
```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.DecisionTree.prototype.getTree" id="apidoc.element.machine_learning.DecisionTree.prototype.getTree">
        function <span class="apidocSignatureSpan">machine_learning.DecisionTree.prototype.</span>getTree
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTree = function () {
    return this.tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.DecisionTree.prototype.print" id="apidoc.element.machine_learning.DecisionTree.prototype.print">
        function <span class="apidocSignatureSpan">machine_learning.DecisionTree.prototype.</span>print
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">print = function () {

    var self = this;
    printTree(self.tree,'');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var dt = new ml.DecisionTree({
    data : data,
    result : result
});

dt.build();

// dt.<span class="apidocCodeKeywordSpan">print</span>();

console.log("Classify : ", dt.classify(['(direct)','USA','yes',5]));

dt.prune(1.0); // 1.0 : mingain.
dt.print();
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.DecisionTree.prototype.prune" id="apidoc.element.machine_learning.DecisionTree.prototype.prune">
        function <span class="apidocSignatureSpan">machine_learning.DecisionTree.prototype.</span>prune
        <span class="apidocSignatureSpan">(mingain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prune = function (mingain){
    var self = this;
    prune(self.tree,mingain);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

dt.build();

// dt.print();

console.log("Classify : ", dt.classify(['(direct)','USA','yes',5]));

dt.<span class="apidocCodeKeywordSpan">prune</span>(1.0); // 1.0 : mingain.
dt.print();
```

## NMF (Non-negative matrix factorization)
```javascript
var ml = require('machine_learning');
var matrix = [[22,28],
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.HiddenLayer" id="apidoc.module.machine_learning.HiddenLayer">module machine_learning.HiddenLayer</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.HiddenLayer.HiddenLayer" id="apidoc.element.machine_learning.HiddenLayer.HiddenLayer">
        function <span class="apidocSignatureSpan">machine_learning.</span>HiddenLayer
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HiddenLayer = function (settings) {
    var self = this;
    self.input = settings['input'];

    if(typeof settings['W'] === 'undefined') {
        var a = 1. / settings['n_in'];
        settings['W'] = math.randMat(settings['n_in'],settings['n_out'],-a,a);
    }
    if(typeof settings['b'] === 'undefined')
        settings['b'] = math.zeroVec(settings['n_out']);
    if(typeof settings['activation'] === 'undefined')
        settings['activation'] = math.sigmoid;

    self.W = settings['W'];
    self.b = settings['b'];
    self.activation = settings['activation'];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.HiddenLayer.prototype" id="apidoc.module.machine_learning.HiddenLayer.prototype">module machine_learning.HiddenLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.HiddenLayer.prototype.backPropagate" id="apidoc.element.machine_learning.HiddenLayer.prototype.backPropagate">
        function <span class="apidocSignatureSpan">machine_learning.HiddenLayer.prototype.</span>backPropagate
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backPropagate = function (input) { // example+num * n_out matrix
    var self = this;
    if(typeof input === 'undefined')
        throw new Error("No BackPropagation Input.")

    var linearOutput = math.mulMat(input, math.transpose(self.W));
    return linearOutput;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/*
 self.nLayers = 3 (3 hidden layers)
 delta[3] : ouput layer
 delta[2] : 3rd hidden layer, delta[0] : 1st hidden layer
 */
for(i = self.nLayers - 1; i&gt;=0 ; i--) {
    delta[i] = math.mulMatElementWise(self.sigmoidLayers[i+1].<span class="apidocCodeKeywordSpan">backPropagate</span>(delta[i+1
]),
        math.activateMat(self.sigmoidLayers[i].linearOutput(layerInput[i]), math.dSigmoid));
}
// Update Weight, Bias
for(var i=0; i&lt;self.nLayers+1 ; i++) {
    var deltaW = math.activateMat(math.mulMat(math.transpose(layerInput[i]),delta[i]),function(x){return 1. * x / self.x.length;})
    var deltaB = math.meanMatAxis(delta[i],0);
    self.sigmoidLayers[i].W = math.addMat(self.sigmoidLayers[i].W,deltaW);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.HiddenLayer.prototype.linearOutput" id="apidoc.element.machine_learning.HiddenLayer.prototype.linearOutput">
        function <span class="apidocSignatureSpan">machine_learning.HiddenLayer.prototype.</span>linearOutput
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">linearOutput = function (input) { // returns the value before activation.
    var self = this;
    if(typeof input !== 'undefined')
        self.input = input;

    var linearOutput = math.addMatVec(math.mulMat(self.input,self.W),self.b);
    return linearOutput;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for(i=0; i&lt;self.nLayers+1 ; i++) {
    layerInput.push(self.sigmoidLayers[i].output(layerInput[i]));
}
var output = layerInput[self.nLayers+1];
// Back Propagation
var delta = new Array(self.nLayers + 1);
delta[self.nLayers] = math.mulMatElementWise(math.minusMat(self.y, output),
    math.activateMat(self.sigmoidLayers[self.nLayers].<span class="apidocCodeKeywordSpan">linearOutput</span>(layerInput[self.nLayers
]), math.dSigmoid));

/*
 self.nLayers = 3 (3 hidden layers)
 delta[3] : ouput layer
 delta[2] : 3rd hidden layer, delta[0] : 1st hidden layer
 */
for(i = self.nLayers - 1; i&gt;=0 ; i--) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.HiddenLayer.prototype.output" id="apidoc.element.machine_learning.HiddenLayer.prototype.output">
        function <span class="apidocSignatureSpan">machine_learning.HiddenLayer.prototype.</span>output
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">output = function (input) {
    var self = this;
    if(typeof input !== 'undefined')
        self.input = input;

    var linearOutput = math.addMatVec(math.mulMat(self.input,self.W),self.b);
    return math.activateMat(linearOutput,self.activation);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(epoch=0 ; epoch &lt; epochs ; epoch++) {

// Feed Forward
var i;
var layerInput = [];
layerInput.push(self.x);
for(i=0; i&lt;self.nLayers+1 ; i++) {
    layerInput.push(self.sigmoidLayers[i].<span class="apidocCodeKeywordSpan">output</span>(layerInput[i]));
}
var output = layerInput[self.nLayers+1];
// Back Propagation
var delta = new Array(self.nLayers + 1);
delta[self.nLayers] = math.mulMatElementWise(math.minusMat(self.y, output),
    math.activateMat(self.sigmoidLayers[self.nLayers].linearOutput(layerInput[self.nLayers]), math.dSigmoid));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.HiddenLayer.prototype.sampleHgivenV" id="apidoc.element.machine_learning.HiddenLayer.prototype.sampleHgivenV">
        function <span class="apidocSignatureSpan">machine_learning.HiddenLayer.prototype.</span>sampleHgivenV
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sampleHgivenV = function (input) {
    var self = this;
    if(typeof input !== 'undefined')
        self.input = input;

    var hMean = self.output();
    var hSample = math.probToBinaryMat(hMean);
    return hSample;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    inputSize = settings['n_ins'];
else
    inputSize = settings['hidden_layer_sizes'][i-1];

if(i == 0)
    layerInput = self.x;
else
    layerInput = self.sigmoidLayers[self.sigmoidLayers.length-1].<span class="apidocCodeKeywordSpan">sampleHgivenV</span>();

var sigmoidLayer;
if(i == self.nLayers) {
    sigmoidLayer = new HiddenLayer({
        'input' : layerInput,
        'n_in' : inputSize,
        'n_out' : settings['n_outs'],
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.KNN" id="apidoc.module.machine_learning.KNN">module machine_learning.KNN</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.KNN.KNN" id="apidoc.element.machine_learning.KNN.KNN">
        function <span class="apidocSignatureSpan">machine_learning.</span>KNN
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">KNN = function (options) {
    var self = this;
    self.data = options['data'];
    self.result = options['result'];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        [0,0,1,0,1,0,1,1,1,1,0,1,1,1],
        [0,0,0,0,0,0,1,1,1,1,1,1,1,1],
        [1,0,1,0,0,1,1,1,1,1,0,0,1,0]
       ];

var result = [23,12,23,23,45,70,123,73,146,158,64];

var knn = new ml.<span class="apidocCodeKeywordSpan">KNN</span>({
data : data,
result : result
});

var y = knn.predict({
x : [0,0,0,0,0,0,0,1,1,1,1,1,1,1],
k : 3,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.KNN.prototype" id="apidoc.module.machine_learning.KNN.prototype">module machine_learning.KNN.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.KNN.prototype.predict" id="apidoc.element.machine_learning.KNN.prototype.predict">
        function <span class="apidocSignatureSpan">machine_learning.KNN.prototype.</span>predict
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predict = function (options) {
    var self = this;
    var x = options['x'];
    var k = options['k'] || 3;
    var weightf = getWeightedFunction(options['weightf']);
    var distance = getDistanceFunction(options['distance']);
    var distanceList = [];
    var i;
    for(i=0; i&lt;self.data.length; i++)
        distanceList.push([distance(x,self.data[i]),i]);
    distanceList.sort(function(a,b) {return a[0]-b[0];});
    var avg = 0.0;
    var totalWeight = 0, weight;
    for(i=0; i&lt;k; i++) {
        var dist = distanceList[i][0];
        var idx = distanceList[i][1];
        weight = weightf(dist);
        avg += weight * self.result[idx];
        totalWeight += weight;
    }

    avg /= totalWeight;
    return avg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'epochs' : training_epochs
});

x = [[1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 1, 0],
     [1, 1, 1, 1, 1, 0]];

console.log("Result : ",classifier.<span class="apidocCodeKeywordSpan">predict</span>(x));
```

## MLP (Multi-Layer Perceptron)
```javascript
var ml = require('machine_learning');
var x = [[0.4, 0.5, 0.5, 0.,  0.,  0.],
[0.5, 0.3,  0.5, 0.,  0.,  0.],
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.LogisticRegression" id="apidoc.module.machine_learning.LogisticRegression">module machine_learning.LogisticRegression</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.LogisticRegression.LogisticRegression" id="apidoc.element.machine_learning.LogisticRegression.LogisticRegression">
        function <span class="apidocSignatureSpan">machine_learning.</span>LogisticRegression
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LogisticRegression = function (settings) {
    var self = this;
    self.x = settings['input'];
    self.y = settings['label'];
    self.W = math.zeroMat(settings['n_in'],settings['n_out']);
    self.b = math.zeroVec(settings['n_out']);
    self.settings = {
        'log level' : 1 // 0 : nothing, 1 : info, 2: warn
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var y = [[1, 0],
         [1, 0],
         [1, 0],
         [0, 1],
         [0, 1],
         [0, 1]];

var classifier = new ml.<span class="apidocCodeKeywordSpan">LogisticRegression</span>({
    'input' : x,
    'label' : y,
    'n_in' : 6,
    'n_out' : 2
});

classifier.set('log level',1);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.LogisticRegression.prototype" id="apidoc.module.machine_learning.LogisticRegression.prototype">module machine_learning.LogisticRegression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.LogisticRegression.prototype.getReconstructionCrossEntropy" id="apidoc.element.machine_learning.LogisticRegression.prototype.getReconstructionCrossEntropy">
        function <span class="apidocSignatureSpan">machine_learning.LogisticRegression.prototype.</span>getReconstructionCrossEntropy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReconstructionCrossEntropy = function () {
    var self = this;
    var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
    var a = math.mulMatElementWise(self.y, math.activateMat(probYgivenX,Math.log));
    var b = math.mulMatElementWise(math.mulMatScalar(math.addMatScalar(self.y,-1),-1),
        math.activateMat(math.mulMatScalar(math.addMatScalar(probYgivenX,-1),-1),Math.log));
    var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));
    return crossEntropy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if(progress &gt; currentProgress) {
            console.log("LogisticRegression",progress.toFixed(0),"% Completed.");
            currentProgress++;
        }
    }
}
if(self.settings['log level'] &gt; 0)
    console.log("LogisticRegression Final Cross Entropy : ",self.<span class="apidocCodeKeywordSpan">getReconstructionCrossEntropy
</span>());
};

LogisticRegression.prototype.getReconstructionCrossEntropy = function () {
var self = this;
var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
var a = math.mulMatElementWise(self.y, math.activateMat(probYgivenX,Math.log));
var b = math.mulMatElementWise(math.mulMatScalar(math.addMatScalar(self.y,-1),-1),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.LogisticRegression.prototype.predict" id="apidoc.element.machine_learning.LogisticRegression.prototype.predict">
        function <span class="apidocSignatureSpan">machine_learning.LogisticRegression.prototype.</span>predict
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predict = function (x) {
    var self = this;
    return math.softmaxMat(math.addMatVec(math.mulMat(x,self.W),self.b));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'epochs' : training_epochs
});

x = [[1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 1, 0],
     [1, 1, 1, 1, 1, 0]];

console.log("Result : ",classifier.<span class="apidocCodeKeywordSpan">predict</span>(x));
```

## MLP (Multi-Layer Perceptron)
```javascript
var ml = require('machine_learning');
var x = [[0.4, 0.5, 0.5, 0.,  0.,  0.],
[0.5, 0.3,  0.5, 0.,  0.,  0.],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.LogisticRegression.prototype.set" id="apidoc.element.machine_learning.LogisticRegression.prototype.set">
        function <span class="apidocSignatureSpan">machine_learning.LogisticRegression.prototype.</span>set
        <span class="apidocSignatureSpan">(property, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (property, value) {
    var self = this;
    self.settings[property] = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var classifier = new ml.LogisticRegression({
    'input' : x,
    'label' : y,
    'n_in' : 6,
    'n_out' : 2
});

classifier.<span class="apidocCodeKeywordSpan">set</span>('log level',1);

var training_epochs = 800, lr = 0.01;

classifier.train({
    'lr' : lr,
    'epochs' : training_epochs
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.LogisticRegression.prototype.train" id="apidoc.element.machine_learning.LogisticRegression.prototype.train">
        function <span class="apidocSignatureSpan">machine_learning.LogisticRegression.prototype.</span>train
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">train = function (settings) {
    var self = this;
    var lr = 0.1, epochs = 200;
    if(typeof settings['input'] !== 'undefined')
        self.x = settings['input'];
    if(typeof settings['lr'] !== 'undefined')
        lr = settings['lr'];
    if(typeof settings['epochs'] !== 'undefined')
        epochs = settings['epochs'];
    var i;
    var currentProgress = 1;
    for(i=0;i&lt;epochs;i++) {
        var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
        var deltaY = math.minusMat(self.y,probYgivenX);

        var deltaW = math.mulMat(math.transpose(self.x),deltaY);
        var deltaB = math.meanMatAxis(deltaY,0);

        self.W = math.addMat(self.W,math.mulMatScalar(deltaW,lr));
        self.b = math.addVec(self.b,math.mulVecScalar(deltaB,lr));
        if(self.settings['log level'] &gt; 0) {
            var progress = (1.*i/epochs)*100;
            if(progress &gt; currentProgress) {
                console.log("LogisticRegression",progress.toFixed(0),"% Completed.");
                currentProgress++;
            }
        }
    }
    if(self.settings['log level'] &gt; 0)
        console.log("LogisticRegression Final Cross Entropy : ",self.getReconstructionCrossEntropy());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'n_out' : 2
});

classifier.set('log level',1);

var training_epochs = 800, lr = 0.01;

classifier.<span class="apidocCodeKeywordSpan">train</span>({
    'lr' : lr,
    'epochs' : training_epochs
});

x = [[1, 1, 0, 0, 0, 0],
[0, 0, 0, 1, 1, 0],
[1, 1, 1, 1, 1, 0]];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.MLP" id="apidoc.module.machine_learning.MLP">module machine_learning.MLP</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.MLP.MLP" id="apidoc.element.machine_learning.MLP.MLP">
        function <span class="apidocSignatureSpan">machine_learning.</span>MLP
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MLP = function (settings) {
    var self = this;
    self.x = settings['input'];
    self.y = settings['label'];
    self.sigmoidLayers = [];
    self.nLayers = settings['hidden_layer_sizes'].length;
    self.settings = {
        'log level' : 1 // 0 : nothing, 1 : info, 2: warn
    };
    var i;
    for(i=0 ; i&lt;self.nLayers+1 ; i++) {
        var inputSize, layerInput;
        if(i == 0)
            inputSize = settings['n_ins'];
        else
            inputSize = settings['hidden_layer_sizes'][i-1];

        if(i == 0)
            layerInput = self.x;
        else
            layerInput = self.sigmoidLayers[self.sigmoidLayers.length-1].sampleHgivenV();

        var sigmoidLayer;
        if(i == self.nLayers) {
            sigmoidLayer = new HiddenLayer({
                'input' : layerInput,
                'n_in' : inputSize,
                'n_out' : settings['n_outs'],
                'activation' : math.sigmoid,
                'W' : (typeof settings['w_array'] === 'undefined')? undefined : settings['w_array'][i],
                'b' : (typeof settings['b_array'] === 'undefined')? undefined : settings['b_array'][i]
            });
        } else {
            sigmoidLayer = new HiddenLayer({
                'input' : layerInput,
                'n_in' : inputSize,
                'n_out' : settings['hidden_layer_sizes'][i],
                'activation' : math.sigmoid,
                'W' : (typeof settings['w_array'] === 'undefined')? undefined : settings['w_array'][i],
                'b' : (typeof settings['b_array'] === 'undefined')? undefined : settings['b_array'][i]
            });
        }
        self.sigmoidLayers.push(sigmoidLayer);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var y = [[1, 0],
         [1, 0],
         [1, 0],
         [0, 1],
         [0, 1],
         [0, 1]];

var mlp = new ml.<span class="apidocCodeKeywordSpan">MLP</span>({
    'input' : x,
    'label' : y,
    'n_ins' : 6,
    'n_outs' : 2,
    'hidden_layer_sizes' : [4,4,5]
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.MLP.prototype" id="apidoc.module.machine_learning.MLP.prototype">module machine_learning.MLP.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.MLP.prototype.getReconstructionCrossEntropy" id="apidoc.element.machine_learning.MLP.prototype.getReconstructionCrossEntropy">
        function <span class="apidocSignatureSpan">machine_learning.MLP.prototype.</span>getReconstructionCrossEntropy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReconstructionCrossEntropy = function () {
    var self = this;
    var reconstructedOutput = self.predict(self.x);
    var a = math.activateTwoMat(self.y,reconstructedOutput,function(x,y){
        return x*Math.log(y);
    });

    var b = math.activateTwoMat(self.y,reconstructedOutput,function(x,y){
        return (1-x)*Math.log(1-y);
    });

    var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));
    return crossEntropy
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if(progress &gt; currentProgress) {
            console.log("LogisticRegression",progress.toFixed(0),"% Completed.");
            currentProgress++;
        }
    }
}
if(self.settings['log level'] &gt; 0)
    console.log("LogisticRegression Final Cross Entropy : ",self.<span class="apidocCodeKeywordSpan">getReconstructionCrossEntropy
</span>());
};

LogisticRegression.prototype.getReconstructionCrossEntropy = function () {
var self = this;
var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
var a = math.mulMatElementWise(self.y, math.activateMat(probYgivenX,Math.log));
var b = math.mulMatElementWise(math.mulMatScalar(math.addMatScalar(self.y,-1),-1),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.MLP.prototype.predict" id="apidoc.element.machine_learning.MLP.prototype.predict">
        function <span class="apidocSignatureSpan">machine_learning.MLP.prototype.</span>predict
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predict = function (x) {
    var self = this;
    var output = x;
    for(i=0; i&lt;self.nLayers+1 ; i++) {
        output = self.sigmoidLayers[i].output(output);
    }
    return output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'epochs' : training_epochs
});

x = [[1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 1, 0],
     [1, 1, 1, 1, 1, 0]];

console.log("Result : ",classifier.<span class="apidocCodeKeywordSpan">predict</span>(x));
```

## MLP (Multi-Layer Perceptron)
```javascript
var ml = require('machine_learning');
var x = [[0.4, 0.5, 0.5, 0.,  0.,  0.],
[0.5, 0.3,  0.5, 0.,  0.,  0.],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.MLP.prototype.set" id="apidoc.element.machine_learning.MLP.prototype.set">
        function <span class="apidocSignatureSpan">machine_learning.MLP.prototype.</span>set
        <span class="apidocSignatureSpan">(property, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (property, value) {
    var self = this;
    self.settings[property] = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var classifier = new ml.LogisticRegression({
    'input' : x,
    'label' : y,
    'n_in' : 6,
    'n_out' : 2
});

classifier.<span class="apidocCodeKeywordSpan">set</span>('log level',1);

var training_epochs = 800, lr = 0.01;

classifier.train({
    'lr' : lr,
    'epochs' : training_epochs
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.MLP.prototype.train" id="apidoc.element.machine_learning.MLP.prototype.train">
        function <span class="apidocSignatureSpan">machine_learning.MLP.prototype.</span>train
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">train = function (settings) {
    var self = this;
    var lr = 0.6, epochs = 1000;
    if(typeof settings['lr'] !== 'undefined')
        lr = settings['lr'];
    if(typeof settings['epochs'] !== 'undefined')
        epochs = settings['epochs'];


    var epoch;
    var currentProgress = 1;
    for(epoch=0 ; epoch &lt; epochs ; epoch++) {

        // Feed Forward
        var i;
        var layerInput = [];
        layerInput.push(self.x);
        for(i=0; i&lt;self.nLayers+1 ; i++) {
            layerInput.push(self.sigmoidLayers[i].output(layerInput[i]));
        }
        var output = layerInput[self.nLayers+1];
        // Back Propagation
        var delta = new Array(self.nLayers + 1);
        delta[self.nLayers] = math.mulMatElementWise(math.minusMat(self.y, output),
            math.activateMat(self.sigmoidLayers[self.nLayers].linearOutput(layerInput[self.nLayers]), math.dSigmoid));

        /*
         self.nLayers = 3 (3 hidden layers)
         delta[3] : ouput layer
         delta[2] : 3rd hidden layer, delta[0] : 1st hidden layer
         */
        for(i = self.nLayers - 1; i&gt;=0 ; i--) {
            delta[i] = math.mulMatElementWise(self.sigmoidLayers[i+1].backPropagate(delta[i+1]),
                math.activateMat(self.sigmoidLayers[i].linearOutput(layerInput[i]), math.dSigmoid));
        }
        // Update Weight, Bias
        for(var i=0; i&lt;self.nLayers+1 ; i++) {
            var deltaW = math.activateMat(math.mulMat(math.transpose(layerInput[i]),delta[i]),function(x){return 1. * x / self.x
.length;})
            var deltaB = math.meanMatAxis(delta[i],0);
            self.sigmoidLayers[i].W = math.addMat(self.sigmoidLayers[i].W,deltaW);
            self.sigmoidLayers[i].b = math.addVec(self.sigmoidLayers[i].b,deltaB);
        }

        if(self.settings['log level'] &gt; 0) {
            var progress = (1.*epoch/epochs)*100;
            if(progress &gt; currentProgress) {
                console.log("MLP",progress.toFixed(0),"% Completed.");
                currentProgress+=8;
            }
        }
    }
    if(self.settings['log level'] &gt; 0)
        console.log("MLP Final Cross Entropy : ",self.getReconstructionCrossEntropy());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'n_out' : 2
});

classifier.set('log level',1);

var training_epochs = 800, lr = 0.01;

classifier.<span class="apidocCodeKeywordSpan">train</span>({
    'lr' : lr,
    'epochs' : training_epochs
});

x = [[1, 1, 0, 0, 0, 0],
[0, 0, 0, 1, 1, 0],
[1, 1, 1, 1, 1, 0]];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.SVM" id="apidoc.module.machine_learning.SVM">module machine_learning.SVM</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.SVM.SVM" id="apidoc.element.machine_learning.SVM.SVM">
        function <span class="apidocSignatureSpan">machine_learning.</span>SVM
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SVM = function (options) {
    var self = this;
    self.x = options['x'];
    self.y = options['y'];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     [0.2, 0.01, 0.5, 0.,  0.,  0.9],
     [0.,  0.,  0.5, 0.3, 0.5, -2.3],
     [0.,  0.,  0.5, 0.4, 0.5, 4],
     [0.,  0.,  0.5, 0.5, 0.5, -2]];

var y =  [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,1,1];

var svm = new ml.<span class="apidocCodeKeywordSpan">SVM</span>({
x : x,
y : y
});

svm.train({
C : 1.1, // default : 1.0. C in SVM.
tol : 1e-5, // default : 1e-4. Higher tolerance --&gt; Higher precision
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.SVM.prototype" id="apidoc.module.machine_learning.SVM.prototype">module machine_learning.SVM.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.SVM.prototype.f" id="apidoc.element.machine_learning.SVM.prototype.f">
        function <span class="apidocSignatureSpan">machine_learning.SVM.prototype.</span>f
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">f = function (x) {
    var self = this;
    var f = 0, j;
    for(j=0; j&lt;self.x.length; j++)
        f += self.alphas[j] * self.y[j] * self.kernel(self.x[j],x);
    f += self.b;
    return f;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var passes = 0, i;
    var count=0;
    while(passes &lt; maxPasses) {
        var numChangedAlphas = 0;

        for(i=0; i&lt;self.x.length; i++) {

            var E_i = self.<span class="apidocCodeKeywordSpan">f</span>(self.x[i]) - self.y[i];

            if((self.y[i] * E_i &lt; -tol &amp;&amp; self.alphas[i] &lt; C) || (self.y[i] * E_i &gt; tol &amp;&amp; self
.alphas[i] &gt;0)) {

// Randomly selects j (i != j)
var j = math.randInt(0,self.x.length-1);
if(i==j) j = (j+1) % self.x.length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.SVM.prototype.predict" id="apidoc.element.machine_learning.SVM.prototype.predict">
        function <span class="apidocSignatureSpan">machine_learning.SVM.prototype.</span>predict
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predict = function (x) {
    var self = this;
    if(self.f(x) &gt;= 0)
        return 1;
    else
        return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'epochs' : training_epochs
});

x = [[1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 1, 0],
     [1, 1, 1, 1, 1, 0]];

console.log("Result : ",classifier.<span class="apidocCodeKeywordSpan">predict</span>(x));
```

## MLP (Multi-Layer Perceptron)
```javascript
var ml = require('machine_learning');
var x = [[0.4, 0.5, 0.5, 0.,  0.,  0.],
[0.5, 0.3,  0.5, 0.,  0.,  0.],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.SVM.prototype.train" id="apidoc.element.machine_learning.SVM.prototype.train">
        function <span class="apidocSignatureSpan">machine_learning.SVM.prototype.</span>train
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">train = function (options) {
    var self = this;
    var C = options['C'] || 1.0;
    var tol = options['tol'] || 1e-4;
    var maxPasses = options['max_passes'] || 20;
    var alphatol = options['alpha_tol'] || 1e-5;

    self.kernel = getKernel(options['kernel']);
    self.alphas = math.zeroVec(self.x.length);
    self.b = 0;
    var passes = 0, i;
    var count=0;
    while(passes &lt; maxPasses) {
        var numChangedAlphas = 0;

        for(i=0; i&lt;self.x.length; i++) {

            var E_i = self.f(self.x[i]) - self.y[i];

            if((self.y[i] * E_i &lt; -tol &amp;&amp; self.alphas[i] &lt; C) || (self.y[i] * E_i &gt; tol &amp;&amp; self.alphas[i] &gt;0)) {

                // Randomly selects j (i != j)
                var j = math.randInt(0,self.x.length-1);
                if(i==j) j = (j+1) % self.x.length;

                var E_j = self.f(self.x[j]) - self.y[j];
                var alpha_i_old = self.alphas[i], alpha_j_old = self.alphas[j];

                // Compute L,H
                var L,H;
                if(self.y[i] !== self.y[j]) {
                    L = Math.max(0, self.alphas[j] - self.alphas[i]);
                    H = Math.min(C, C + self.alphas[j] - self.alphas[i]);
                } else {
                    L = Math.max(0, self.alphas[j] + self.alphas[i] - C);
                    H = Math.min(C, self.alphas[j] + self.alphas[i]);
                }

                if(L === H)
                    continue;

                // Compute ETA
                var ETA = 2 * self.kernel(self.x[i],self.x[j]) - self.kernel(self.x[i],self.x[i]) - self.kernel(self.x[j],self.x
[j]);
                if(ETA &gt;= 0)
                    continue;

                // Clip new value to alpha_j
                self.alphas[j] -= 1.*self.y[j] * (E_i - E_j) / ETA;
                if(self.alphas[j] &gt; H)
                    self.alphas[j] = H;
                else if(self.alphas[j] &lt; L)
                    self.alphas[j] = L;

                if(Math.abs(self.alphas[j] - alpha_j_old) &lt; alphatol)
                    continue;

                // Clip new value to alpha_i
                self.alphas[i] += self.y[i] * self.y[j] * (alpha_j_old - self.alphas[j]);

                // update b
                var b1 = self.b - E_i - self.y[i] * (self.alphas[i] - alpha_i_old) * self.kernel(self.x[i],self.x[i])
                                - self.y[j] * (self.alphas[j] - alpha_j_old) * self.kernel(self.x[i],self.x[j]);
                var b2 = self.b - E_j - self.y[i] * (self.alphas[i] - alpha_i_old) * self.kernel(self.x[i],self.x[j])
                                - self.y[j] * (self.alphas[j] - alpha_j_old) * self.kernel(self.x[j],self.x[j]);

                if(0 &lt; self.alphas[i] &amp;&amp; self.alphas[i] &lt; C)
                    self.b = b1;
                else if(0 &lt; self.alphas[j] &amp;&amp; self.alphas[j] &lt; C)
                    self.b = b2;
                else
                    self.b = (b1+b2)/2.0;

                numChangedAlphas ++ ;
            } // end-if
        } // end-for
        if(numChangedAlphas == 0)
            passes++;
        else
            passes = 0;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'n_out' : 2
});

classifier.set('log level',1);

var training_epochs = 800, lr = 0.01;

classifier.<span class="apidocCodeKeywordSpan">train</span>({
    'lr' : lr,
    'epochs' : training_epochs
});

x = [[1, 1, 0, 0, 0, 0],
[0, 0, 0, 1, 1, 0],
[1, 1, 1, 1, 1, 0]];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.kmeans" id="apidoc.module.machine_learning.kmeans">module machine_learning.kmeans</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.kmeans.cluster" id="apidoc.element.machine_learning.kmeans.cluster">
        function <span class="apidocSignatureSpan">machine_learning.kmeans.</span>cluster
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cluster = function (options) {
    var data = options['data'];
    var k = options['k'];
    var distance = getDistanceFunction(options['distance']);
    var epochs = options['epochs'];
    var init_using_data = options['init_using_data'];
    if(typeof init_using_data === "undefined");
        init_using_data = true;
    var means = getRandomMeans(data,k, init_using_data);

    var epoch, i, j, l;
    var clusters = [];
    for(i=0 ; i&lt;k ; i++)
        clusters.push([]);

    for(epoch=0 ; epoch&lt;epochs ; epoch++) {
        clusters = [];
        for(i=0 ; i&lt;k ; i++)
            clusters.push([]);

        // Find which centroid is the closest for each row
        for(i=0 ; i&lt;data.length ; i++) {
            var bestmatch = 0;
            for(j=0 ; j&lt;k ; j++) {
                if(distance(means[j],data[i]) &lt; distance(means[bestmatch],data[i])) bestmatch = j;
            }
            clusters[bestmatch].push(i);
        }

        // Move the centroids to the average of their members
        for(i=0 ; i&lt;k ; i++) {
            var avgs = [];
            for(j=0 ; j&lt;data[0].length ; j++)
                avgs.push(0.0);
            if(clusters[i].length &gt; 0) {
                for(j=0 ; j&lt;clusters[i].length ; j++) {
                    for(l=0 ; l&lt;data[0].length ; l++) {
                        avgs[l] += data[clusters[i][j]][l];
                    }
                }
                for(j=0 ; j&lt;data[0].length ; j++) {
                    avgs[j] /= clusters[i].length;
                }
                means[i] = avgs;
            }
        }
    }
    return {
        clusters : clusters,
        means : means
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        [0,0,0,0,0,0,1,1,1,0,1,1,1,0],
        [0,0,0,0,0,1,1,1,0,1,0,1,1,0],
        [0,0,1,0,1,0,1,1,1,1,0,1,1,1],
        [0,0,0,0,0,0,1,1,1,1,1,1,1,1],
        [1,0,1,0,0,1,1,1,1,1,0,0,1,0]
       ];

var result = ml.kmeans.<span class="apidocCodeKeywordSpan">cluster</span>({
data : data,
k : 4,
epochs: 100,

distance : {type : "pearson"}
// default : {type : 'euclidean'}
// {type : 'pearson'}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.math" id="apidoc.module.machine_learning.math">module machine_learning.math</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.math.activateMat" id="apidoc.element.machine_learning.math.activateMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>activateMat
        <span class="apidocSignatureSpan">(mat, activation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">activateMat = function (mat, activation) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i, j,result = [];
    for(i=0;i&lt;row;i++) {
        var rowVec = [];
        for(j=0;j&lt;col;j++)
            rowVec.push(activation(mat[i][j]));
        result.push(rowVec);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

HiddenLayer.prototype.output = function(input) {
var self = this;
if(typeof input !== 'undefined')
    self.input = input;

var linearOutput = math.addMatVec(math.mulMat(self.input,self.W),self.b);
return math.<span class="apidocCodeKeywordSpan">activateMat</span>(linearOutput,self.activation);
};

HiddenLayer.prototype.linearOutput = function(input) { // returns the value before activation.
var self = this;
if(typeof input !== 'undefined')
    self.input = input;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.activateTwoMat" id="apidoc.element.machine_learning.math.activateTwoMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>activateTwoMat
        <span class="apidocSignatureSpan">(mat1, mat2, activation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">activateTwoMat = function (mat1, mat2, activation) {
    if (mat1.length === mat2.length &amp;&amp; mat1[0].length === mat2[0].length) {
        var result = new Array(mat1.length);

        for (var x = 0; x &lt; mat1.length; x++) {
            result[x] = new Array(mat1[0].length);
        }

        for (var i = 0; i &lt; result.length; i++) {
            for (var j = 0; j &lt; result[i].length; j++) {
                result[i][j] = activation(mat1[i][j],mat2[i][j]);
            }
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(self.settings['log level'] &gt; 0)
    console.log("MLP Final Cross Entropy : ",self.getReconstructionCrossEntropy());
};

MLP.prototype.getReconstructionCrossEntropy = function() {
var self = this;
var reconstructedOutput = self.predict(self.x);
var a = math.<span class="apidocCodeKeywordSpan">activateTwoMat</span>(self.y,reconstructedOutput,function(x,y){
    return x*Math.log(y);
});

var b = math.activateTwoMat(self.y,reconstructedOutput,function(x,y){
    return (1-x)*Math.log(1-y);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.activateTwoVec" id="apidoc.element.machine_learning.math.activateTwoVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>activateTwoVec
        <span class="apidocSignatureSpan">(vec1, vec2, activation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">activateTwoVec = function (vec1, vec2, activation) {
    if (vec1.length === vec2.length) {
        var result = new Array(vec1.length);
        for (var i = 0; i &lt; result.length; i++) {
            result[i] = activation(vec1[i],vec2[i]);
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.activateVec" id="apidoc.element.machine_learning.math.activateVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>activateVec
        <span class="apidocSignatureSpan">(vec, activation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">activateVec = function (vec, activation) {
    var i, result = [];
    for(i=0;i&lt;vec.length;i++)
        result.push(activation(vec[i]));
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    mat.push(rowVec);
}
return mat;
};

m.softmaxVec = function(vec) {
var max = m.maxVec(vec);
var preSoftmaxVec = m.<span class="apidocCodeKeywordSpan">activateVec</span>(vec,function(x) {return Math.exp(x - max);})
return m.activateVec(preSoftmaxVec,function(x) {return x/ m.sumVec(preSoftmaxVec)})
};

m.softmaxMat = function(mat) {
var result=[], i;
for(i=0 ; i&lt;mat.length ; i++)
    result.push(m.softmaxVec(mat[i]));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.addMat" id="apidoc.element.machine_learning.math.addMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>addMat
        <span class="apidocSignatureSpan">(mat1, mat2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addMat = function (mat1, mat2) {
    if ((mat1.length === mat2.length) &amp;&amp; (mat1[0].length === mat2[0].length)) {
        var result = new Array(mat1.length);
        for (var i = 0; i &lt; mat1.length; i++) {
            result[i] = new Array(mat1[i].length);
            for (var j = 0; j &lt; mat1[i].length; j++) {
                result[i][j] = mat1[i][j] + mat2[i][j];
            }
        }
        return result;
    } else {
        throw new Error('Matrix mismatch.');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(i=0;i&lt;epochs;i++) {
var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
var deltaY = math.minusMat(self.y,probYgivenX);

var deltaW = math.mulMat(math.transpose(self.x),deltaY);
var deltaB = math.meanMatAxis(deltaY,0);

self.W = math.<span class="apidocCodeKeywordSpan">addMat</span>(self.W,math.mulMatScalar(deltaW,lr));
self.b = math.addVec(self.b,math.mulVecScalar(deltaB,lr));
if(self.settings['log level'] &gt; 0) {
    var progress = (1.*i/epochs)*100;
    if(progress &gt; currentProgress) {
        console.log("LogisticRegression",progress.toFixed(0),"% Completed.");
        currentProgress++;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.addMatScalar" id="apidoc.element.machine_learning.math.addMatScalar">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>addMatScalar
        <span class="apidocSignatureSpan">(mat, scalar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addMatScalar = function (mat, scalar) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i , j,result = [];
    for(i=0 ; i&lt;row ; i++) {
        var rowVec = [];
        for(j=0 ; j&lt;col ; j++) {
            rowVec.push(mat[i][j] + scalar);
        }
        result.push(rowVec);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    console.log("LogisticRegression Final Cross Entropy : ",self.getReconstructionCrossEntropy());
};

LogisticRegression.prototype.getReconstructionCrossEntropy = function () {
var self = this;
var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
var a = math.mulMatElementWise(self.y, math.activateMat(probYgivenX,Math.log));
var b = math.mulMatElementWise(math.mulMatScalar(math.<span class="apidocCodeKeywordSpan">addMatScalar</span>(self.y,-1),-1),
    math.activateMat(math.mulMatScalar(math.addMatScalar(probYgivenX,-1),-1),Math.log));
var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));
return crossEntropy;
};

LogisticRegression.prototype.predict = function (x) {
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.addMatVec" id="apidoc.element.machine_learning.math.addMatVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>addMatVec
        <span class="apidocSignatureSpan">(mat, vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addMatVec = function (mat, vec) {
    if(mat[0].length === vec.length) {
        var result = [];
        var i;
        for(i=0;i&lt;mat.length;i++)
            result.push(m.addVec(mat[i],vec));
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

HiddenLayer.prototype.output = function(input) {
var self = this;
if(typeof input !== 'undefined')
    self.input = input;

var linearOutput = math.<span class="apidocCodeKeywordSpan">addMatVec</span>(math.mulMat(self.input,self.W),self.b);
return math.activateMat(linearOutput,self.activation);
};

HiddenLayer.prototype.linearOutput = function(input) { // returns the value before activation.
var self = this;
if(typeof input !== 'undefined')
    self.input = input;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.addVec" id="apidoc.element.machine_learning.math.addVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>addVec
        <span class="apidocSignatureSpan">(vec1, vec2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addVec = function (vec1, vec2) {
    if(vec1.length === vec2.length) {
        var result = [];
        var i;
        for(i=0;i&lt;vec1.length;i++)
            result.push(vec1[i]+vec2[i]);
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
var deltaY = math.minusMat(self.y,probYgivenX);

var deltaW = math.mulMat(math.transpose(self.x),deltaY);
var deltaB = math.meanMatAxis(deltaY,0);

self.W = math.addMat(self.W,math.mulMatScalar(deltaW,lr));
self.b = math.<span class="apidocCodeKeywordSpan">addVec</span>(self.b,math.mulVecScalar(deltaB,lr));
if(self.settings['log level'] &gt; 0) {
    var progress = (1.*i/epochs)*100;
    if(progress &gt; currentProgress) {
        console.log("LogisticRegression",progress.toFixed(0),"% Completed.");
        currentProgress++;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.covarianceVecs" id="apidoc.element.machine_learning.math.covarianceVecs">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>covarianceVecs
        <span class="apidocSignatureSpan">(vecs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">covarianceVecs = function (vecs) {
    var mat = m.zeroMat(vecs[0].length,vecs[0].length);
    var meanVec = m.meanVecs(vecs);
    var i;
    for(i=0; i&lt;vecs.length; i++) {
        var a = m.minusVec(vecs[i],meanVec);
        mat = m.addMat(mat, m.mulMat(m.transpose([a]),[a]));
    }
    return m.activateMat(mat,function(x) { return 1.*x/(vecs.length-1);});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.dSigmoid" id="apidoc.element.machine_learning.math.dSigmoid">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>dSigmoid
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dSigmoid = function (x){
    a = m.sigmoid(x);
    return a * (1. - a);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.dotVec" id="apidoc.element.machine_learning.math.dotVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>dotVec
        <span class="apidocSignatureSpan">(vec1, vec2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dotVec = function (vec1, vec2) {
    if (vec1.length === vec2.length) {
        var result = 0;
        for (var i = 0; i &lt; vec1.length; i++) {
            result += vec1[i] * vec2[i];
        }
        return result;
    } else {
        throw new Error("Vector mismatch");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            result[x] = new Array(mat2[0].length);
        }


        var mat2_T = m.transpose(mat2);
        for (var i = 0; i &lt; result.length; i++) {
            for (var j = 0; j &lt; result[i].length; j++) {
                result[i][j] = m.<span class="apidocCodeKeywordSpan">dotVec</span>(mat1[i],mat2_T[j]);
            }
        }
        return result;
    } else {
        throw new Error("Array mismatch");
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.euclidean" id="apidoc.element.machine_learning.math.euclidean">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>euclidean
        <span class="apidocSignatureSpan">(x1, x2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">euclidean = function (x1, x2) {
    var i;
    var distance = 0;
    for(i=0 ; i&lt;x1.length; i++) {
        var dx = x1[i] - x2[i];
        distance += dx * dx;
    }
    return Math.sqrt(distance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.fillMat" id="apidoc.element.machine_learning.math.fillMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>fillMat
        <span class="apidocSignatureSpan">(row, col, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fillMat = function (row, col, value) {
    var mat = [];
    while(mat.length &lt; row) {
        var rowVec = [];
        while(rowVec.length &lt; col)
            rowVec.push(value);
        mat.push(rowVec);
    }
    return mat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.fillVec" id="apidoc.element.machine_learning.math.fillVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>fillVec
        <span class="apidocSignatureSpan">(n, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fillVec = function (n, value) {
    var vec = [];
    while(vec.length &lt; n)
        vec.push(value);
    return vec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.gaussian" id="apidoc.element.machine_learning.math.gaussian">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>gaussian
        <span class="apidocSignatureSpan">(x, sigma)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gaussian = function (x, sigma) {
    sigma = sigma || 10.0;
    return Math.exp(-1.*x*x/(2*sigma*sigma));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.getNormVec" id="apidoc.element.machine_learning.math.getNormVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>getNormVec
        <span class="apidocSignatureSpan">(vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNormVec = function (vec) {
    var i;
    var sqsum = 0;
    for(i=0; i&lt;vec.length; i++)
        sqsum += vec[i] * vec[i];
    return Math.sqrt(sqsum);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return f;
}

function getKernel (options) {
if(typeof options === 'undefined') {
    return function(x,y) {
        var sigma = 1.0;
        return Math.exp(-1.*Math.pow(math.<span class="apidocCodeKeywordSpan">getNormVec</span>(math.minusVec(x,y)),2)/(2*sigma*
sigma));
    }
} else if (typeof options === 'function') {
    return options;
} else if (options['type'] === 'gaussian') {
    return function(x,y) {
        var sigma = options['sigma'];
        return Math.exp(-1.*Math.pow(math.getNormVec(math.minusVec(x,y)),2)/(2*sigma*sigma));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.identity" id="apidoc.element.machine_learning.math.identity">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>identity
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (n) {
    var result = new Array(n);

    for (var i = 0; i &lt; n ; i++) {
        result[i] = new Array(n);
        for (var j = 0; j &lt; n; j++) {
            result[i][j] = (i === j) ? 1 : 0;
        }
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.maxMat" id="apidoc.element.machine_learning.math.maxMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>maxMat
        <span class="apidocSignatureSpan">(mat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxMat = function (mat) {
    var max = mat[0][0];
    var i = mat.length;
    while (i--) {
        for(var j=0;j&lt;mat[0].length;j++) {
            if(mat[i][j] &lt; max)
                max = mat[i][j];
        }
    }
    return max;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.maxVec" id="apidoc.element.machine_learning.math.maxVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>maxVec
        <span class="apidocSignatureSpan">(vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxVec = function (vec) {
    var max = vec[0];
    var i = vec.length;
    while (i--) {
        if (vec[i] &gt; max)
            max = vec[i];
    }
    return max;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        rowVec.push(value);
    mat.push(rowVec);
}
return mat;
};

m.softmaxVec = function(vec) {
var max = m.<span class="apidocCodeKeywordSpan">maxVec</span>(vec);
var preSoftmaxVec = m.activateVec(vec,function(x) {return Math.exp(x - max);})
return m.activateVec(preSoftmaxVec,function(x) {return x/ m.sumVec(preSoftmaxVec)})
};

m.softmaxMat = function(mat) {
var result=[], i;
for(i=0 ; i&lt;mat.length ; i++)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.meanMat" id="apidoc.element.machine_learning.math.meanMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>meanMat
        <span class="apidocSignatureSpan">(mat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">meanMat = function (mat) {
    var row = mat.length;
    var col = mat[0].length;
    return 1. * m.sumMat(mat) / (row * col);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.meanMatAxis" id="apidoc.element.machine_learning.math.meanMatAxis">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>meanMatAxis
        <span class="apidocSignatureSpan">(mat, axis)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">meanMatAxis = function (mat, axis) {
    // default axis 0;
    // axis 0 : mean of col vector . axis 1 : mean of row vector
    if(axis === 1) {
        var row = m.shape(mat)[0];
        var i ;
        var result = [];
        for(i=0 ; i&lt;row; i++)
            result.push(m.meanVec(mat[i]));
        return result;
    } else {
        mat_T = m.transpose(mat);
        return m.meanMatAxis(mat_T,1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var i;
    var currentProgress = 1;
    for(i=0;i&lt;epochs;i++) {
var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
var deltaY = math.minusMat(self.y,probYgivenX);

var deltaW = math.mulMat(math.transpose(self.x),deltaY);
var deltaB = math.<span class="apidocCodeKeywordSpan">meanMatAxis</span>(deltaY,0);

self.W = math.addMat(self.W,math.mulMatScalar(deltaW,lr));
self.b = math.addVec(self.b,math.mulVecScalar(deltaB,lr));
if(self.settings['log level'] &gt; 0) {
    var progress = (1.*i/epochs)*100;
    if(progress &gt; currentProgress) {
        console.log("LogisticRegression",progress.toFixed(0),"% Completed.");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.meanVec" id="apidoc.element.machine_learning.math.meanVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>meanVec
        <span class="apidocSignatureSpan">(vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">meanVec = function (vec) {
    return 1. * m.sumVec(vec) / vec.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

LogisticRegression.prototype.getReconstructionCrossEntropy = function () {
    var self = this;
    var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
    var a = math.mulMatElementWise(self.y, math.activateMat(probYgivenX,Math.log));
    var b = math.mulMatElementWise(math.mulMatScalar(math.addMatScalar(self.y,-1),-1),
        math.activateMat(math.mulMatScalar(math.addMatScalar(probYgivenX,-1),-1),Math.log));
    var crossEntropy = -math.<span class="apidocCodeKeywordSpan">meanVec</span>(math.sumMatAxis(math.addMat(a,b),1));
    return crossEntropy;
};

LogisticRegression.prototype.predict = function (x) {
    var self = this;
    return math.softmaxMat(math.addMatVec(math.mulMat(x,self.W),self.b));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.meanVecs" id="apidoc.element.machine_learning.math.meanVecs">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>meanVecs
        <span class="apidocSignatureSpan">(vecs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">meanVecs = function (vecs) {
    var sum = m.zeroVec(vecs[0].length);
    var i;
    for(i=0; i&lt;vecs.length; i++)
        sum = m.addVec(sum,vecs[i]);
    return m.activateVec(sum,function(x) {return 1.*x/vecs.length;});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(i=0; i&lt;vecs.length; i++)
        sum = m.addVec(sum,vecs[i]);
    return m.activateVec(sum,function(x) {return 1.*x/vecs.length;});
};

m.covarianceVecs = function(vecs) {
    var mat = m.zeroMat(vecs[0].length,vecs[0].length);
    var meanVec = m.<span class="apidocCodeKeywordSpan">meanVecs</span>(vecs);
    var i;
    for(i=0; i&lt;vecs.length; i++) {
        var a = m.minusVec(vecs[i],meanVec);
        mat = m.addMat(mat, m.mulMat(m.transpose([a]),[a]));
    }
    return m.activateMat(mat,function(x) { return 1.*x/(vecs.length-1);});
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.minMat" id="apidoc.element.machine_learning.math.minMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>minMat
        <span class="apidocSignatureSpan">(mat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minMat = function (mat) {
    var min = mat[0][0];
    var i = mat.length;
    while (i--) {
        for(var j=0;j&lt;mat[0].length;j++) {
            if(mat[i][j] &lt; min)
                min = mat[i][j];
        }
    }
    return min;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.minVec" id="apidoc.element.machine_learning.math.minVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>minVec
        <span class="apidocSignatureSpan">(vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minVec = function (vec) {
    var min = vec[0];
    var i = vec.length;
    while (i--) {
        if (vec[i] &lt; min)
            min = vec[i];
    }
    return min;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.minusMat" id="apidoc.element.machine_learning.math.minusMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>minusMat
        <span class="apidocSignatureSpan">(mat1, mat2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minusMat = function (mat1, mat2) {
    if ((mat1.length === mat2.length) &amp;&amp; (mat1[0].length === mat2[0].length)) {
        var result = new Array(mat1.length);
        for (var i = 0; i &lt; mat1.length; i++) {
            result[i] = new Array(mat1[i].length);
            for (var j = 0; j &lt; mat1[i].length; j++) {
                result[i][j] = mat1[i][j] - mat2[i][j];
            }
        }
        return result;
    } else {
        throw new Error('Matrix mismatch.');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
lr = settings['lr'];
    if(typeof settings['epochs'] !== 'undefined')
epochs = settings['epochs'];
    var i;
    var currentProgress = 1;
    for(i=0;i&lt;epochs;i++) {
var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
var deltaY = math.<span class="apidocCodeKeywordSpan">minusMat</span>(self.y,probYgivenX);

var deltaW = math.mulMat(math.transpose(self.x),deltaY);
var deltaB = math.meanMatAxis(deltaY,0);

self.W = math.addMat(self.W,math.mulMatScalar(deltaW,lr));
self.b = math.addVec(self.b,math.mulVecScalar(deltaB,lr));
if(self.settings['log level'] &gt; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.minusMatVec" id="apidoc.element.machine_learning.math.minusMatVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>minusMatVec
        <span class="apidocSignatureSpan">(mat, vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minusMatVec = function (mat, vec) {
    if(mat[0].length === vec.length) {
        var result = [];
        var i;
        for(i=0;i&lt;mat.length;i++)
            result.push(m.minusVec(mat[i],vec));
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.minusVec" id="apidoc.element.machine_learning.math.minusVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>minusVec
        <span class="apidocSignatureSpan">(vec1, vec2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minusVec = function (vec1, vec2) {
    if(vec1.length === vec2.length) {
        var result = [];
        var i;
        for(i=0;i&lt;vec1.length;i++)
            result.push(vec1[i]-vec2[i]);
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

m.minusMatVec = function(mat,vec) {
    if(mat[0].length === vec.length) {
        var result = [];
        var i;
        for(i=0;i&lt;mat.length;i++)
            result.push(m.<span class="apidocCodeKeywordSpan">minusVec</span>(mat[i],vec));
        return result;
    } else {
        throw new Error("Length Error : not same.")
    }
}

m.addMat = function (mat1, mat2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.mulMat" id="apidoc.element.machine_learning.math.mulMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>mulMat
        <span class="apidocSignatureSpan">(mat1, mat2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mulMat = function (mat1, mat2) {
    if (mat1[0].length === mat2.length) {
        var result = new Array(mat1.length);

        for (var x = 0; x &lt; mat1.length; x++) {
            result[x] = new Array(mat2[0].length);
        }


        var mat2_T = m.transpose(mat2);
        for (var i = 0; i &lt; result.length; i++) {
            for (var j = 0; j &lt; result[i].length; j++) {
                result[i][j] = m.dotVec(mat1[i],mat2_T[j]);
            }
        }
        return result;
    } else {
        throw new Error("Array mismatch");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

HiddenLayer.prototype.output = function(input) {
var self = this;
if(typeof input !== 'undefined')
    self.input = input;

var linearOutput = math.addMatVec(math.<span class="apidocCodeKeywordSpan">mulMat</span>(self.input,self.W),self.b);
return math.activateMat(linearOutput,self.activation);
};

HiddenLayer.prototype.linearOutput = function(input) { // returns the value before activation.
var self = this;
if(typeof input !== 'undefined')
    self.input = input;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.mulMatElementWise" id="apidoc.element.machine_learning.math.mulMatElementWise">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>mulMatElementWise
        <span class="apidocSignatureSpan">(mat1, mat2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mulMatElementWise = function (mat1, mat2) {
    if (mat1.length === mat2.length &amp;&amp; mat1[0].length === mat2[0].length) {
        var result = new Array(mat1.length);

        for (var x = 0; x &lt; mat1.length; x++) {
            result[x] = new Array(mat1[0].length);
        }

        for (var i = 0; i &lt; result.length; i++) {
            for (var j = 0; j &lt; result[i].length; j++) {
                result[i][j] = mat1[i][j] * mat2[i][j]
            }
        }
        return result;
    } else {
        throw new Error("Matrix shape error : not same");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(self.settings['log level'] &gt; 0)
        console.log("LogisticRegression Final Cross Entropy : ",self.getReconstructionCrossEntropy());
};

LogisticRegression.prototype.getReconstructionCrossEntropy = function () {
    var self = this;
    var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
    var a = math.<span class="apidocCodeKeywordSpan">mulMatElementWise</span>(self.y, math.activateMat(probYgivenX,Math.log));
    var b = math.mulMatElementWise(math.mulMatScalar(math.addMatScalar(self.y,-1),-1),
        math.activateMat(math.mulMatScalar(math.addMatScalar(probYgivenX,-1),-1),Math.log));
    var crossEntropy = -math.meanVec(math.sumMatAxis(math.addMat(a,b),1));
    return crossEntropy;
};

LogisticRegression.prototype.predict = function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.mulMatScalar" id="apidoc.element.machine_learning.math.mulMatScalar">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>mulMatScalar
        <span class="apidocSignatureSpan">(mat, scalar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mulMatScalar = function (mat, scalar) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i , j,result = [];
    for(i=0 ; i&lt;row ; i++) {
        var rowVec = [];
        for(j=0 ; j&lt;col ; j++) {
            rowVec.push(mat[i][j] * scalar);
        }
        result.push(rowVec);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(i=0;i&lt;epochs;i++) {
var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
var deltaY = math.minusMat(self.y,probYgivenX);

var deltaW = math.mulMat(math.transpose(self.x),deltaY);
var deltaB = math.meanMatAxis(deltaY,0);

self.W = math.addMat(self.W,math.<span class="apidocCodeKeywordSpan">mulMatScalar</span>(deltaW,lr));
self.b = math.addVec(self.b,math.mulVecScalar(deltaB,lr));
if(self.settings['log level'] &gt; 0) {
    var progress = (1.*i/epochs)*100;
    if(progress &gt; currentProgress) {
        console.log("LogisticRegression",progress.toFixed(0),"% Completed.");
        currentProgress++;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.mulVecScalar" id="apidoc.element.machine_learning.math.mulVecScalar">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>mulVecScalar
        <span class="apidocSignatureSpan">(vec, scalar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mulVecScalar = function (vec, scalar) {
    var i, result = [];
    for(i=0;i&lt;vec.length;i++)
        result.push(vec[i]*scalar);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
var deltaY = math.minusMat(self.y,probYgivenX);

var deltaW = math.mulMat(math.transpose(self.x),deltaY);
var deltaB = math.meanMatAxis(deltaY,0);

self.W = math.addMat(self.W,math.mulMatScalar(deltaW,lr));
self.b = math.addVec(self.b,math.<span class="apidocCodeKeywordSpan">mulVecScalar</span>(deltaB,lr));
if(self.settings['log level'] &gt; 0) {
    var progress = (1.*i/epochs)*100;
    if(progress &gt; currentProgress) {
        console.log("LogisticRegression",progress.toFixed(0),"% Completed.");
        currentProgress++;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.normalizeVec" id="apidoc.element.machine_learning.math.normalizeVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>normalizeVec
        <span class="apidocSignatureSpan">(vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeVec = function (vec) {
    var i;
    var newVec = [],tot = 0;
    for(i=0; i&lt;vec.length; i++)
        tot += vec[i];
    for(i=0; i&lt;vec.length;i++)
        newVec.push(1.*vec[i]/tot);
    return newVec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for(j=0;j&lt;elite;j++)
    newPop.push(pop[j]);

// compute fitnesses
var fitnesses = [];
for(j=0; j&lt;pop.length; j++)
    fitnesses[j] = q * Math.pow(1-q,j);
fitnesses = math.<span class="apidocCodeKeywordSpan">normalizeVec</span>(fitnesses);

// crossover, mutate
for(j=0; j&lt;pop.length - elite;j++) {
    var idx1 = rouletteWheel(fitnesses);
    var idx2 = rouletteWheel(fitnesses);
    var crossovered = crossover(pop[idx1],pop[idx2]);
    var mutated = mutate(crossovered);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.oneMat" id="apidoc.element.machine_learning.math.oneMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>oneMat
        <span class="apidocSignatureSpan">(row, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">oneMat = function (row, col) {
    var mat = [];
    while(mat.length &lt; row)
        mat.push(m.oneVec(col));
    return mat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.oneVec" id="apidoc.element.machine_learning.math.oneVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>oneVec
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">oneVec = function (n) {
    var vec = [];
    while(vec.length &lt; n)
        vec.push(1);
    return vec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    vec.push(1);
return vec;
};

m.oneMat = function(row,col) {
var mat = [];
while(mat.length &lt; row)
    mat.push(m.<span class="apidocCodeKeywordSpan">oneVec</span>(col));
return mat;
};

m.randVec = function(n,lower,upper) {
lower = (typeof lower !== 'undefined') ? lower : 0;
upper = (typeof upper !== 'undefined') ? upper : 1;
var vec = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.outerVec" id="apidoc.element.machine_learning.math.outerVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>outerVec
        <span class="apidocSignatureSpan">(vec1, vec2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outerVec = function (vec1, vec2) {
    var mat1 = m.transpose([vec1]);
    var mat2 = [vec2];
    return m.mulMat(mat1,mat2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.pearson" id="apidoc.element.machine_learning.math.pearson">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>pearson
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pearson = function (x, y)
{
    var xy = [];
    var x2 = [];
    var y2 = [];

    for(var i=0; i&lt;x.length; i++)
    {
        xy.push(x[i] * y[i]);
        x2.push(x[i] * x[i]);
        y2.push(y[i] * y[i]);
    }

    var sum_x = 0;
    var sum_y = 0;
    var sum_xy = 0;
    var sum_x2 = 0;
    var sum_y2 = 0;

    for(var i=0; i&lt;x.length; i++)
    {
        sum_x += x[i];
        sum_y += y[i];
        sum_xy += xy[i];
        sum_x2 += x2[i];
        sum_y2 += y2[i];
    }

    var step1 = (x.length * sum_xy) - (sum_x * sum_y);
    var step2 = (x.length * sum_x2) - (sum_x * sum_x);
    var step3 = (x.length * sum_y2) - (sum_y * sum_y);
    var step4 = Math.sqrt(step2 * step3);
    var answer = step1 / step4;

    return answer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.probToBinaryMat" id="apidoc.element.machine_learning.math.probToBinaryMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>probToBinaryMat
        <span class="apidocSignatureSpan">(mat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">probToBinaryMat = function (mat) {
    var row = m.shape(mat)[0];
    var col = m.shape(mat)[1];
    var i,j;
    var result = [];

    for(i=0;i&lt;row;i++) {
        var rowVec = [];
        for(j=0;j&lt;col;j++) {
            if(Math.random() &lt; mat[i][j])
                rowVec.push(1);
            else
                rowVec.push(0);
        }
        result.push(rowVec);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.randInt" id="apidoc.element.machine_learning.math.randInt">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>randInt
        <span class="apidocSignatureSpan">(min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randInt = function (min, max) {
  var rand = Math.random() * (max - min + 0.9999) + min
  return Math.floor(rand);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
optimize.hillclimb = function(options){
var domain = options['domain'];
var costf = options['costf'];

var i;
var vec = [];
for(i=0 ; i&lt;domain.length ; i++)
    vec.push(math.<span class="apidocCodeKeywordSpan">randInt</span>(domain[i][0],domain[i][1]));

var current, best;

while(true) {
    var neighbors = [];
    var i,j;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.randMat" id="apidoc.element.machine_learning.math.randMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>randMat
        <span class="apidocSignatureSpan">(row, col, lower, upper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randMat = function (row, col, lower, upper) {
    lower = (typeof lower !== 'undefined') ? lower : 0;
    upper = (typeof upper !== 'undefined') ? upper : 1;
    var mat = [];
    while(mat.length &lt; row)
        mat.push(m.randVec(col,lower,upper));
    return mat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var math = require('./utils').math;
let HiddenLayer = module.exports = function (settings) {
var self = this;
self.input = settings['input'];

if(typeof settings['W'] === 'undefined') {
    var a = 1. / settings['n_in'];
    settings['W'] = math.<span class="apidocCodeKeywordSpan">randMat</span>(settings['n_in'],settings['
n_out'],-a,a);
}
if(typeof settings['b'] === 'undefined')
    settings['b'] = math.zeroVec(settings['n_out']);
if(typeof settings['activation'] === 'undefined')
    settings['activation'] = math.sigmoid;

self.W = settings['W'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.randVec" id="apidoc.element.machine_learning.math.randVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>randVec
        <span class="apidocSignatureSpan">(n, lower, upper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randVec = function (n, lower, upper) {
    lower = (typeof lower !== 'undefined') ? lower : 0;
    upper = (typeof upper !== 'undefined') ? upper : 1;
    var vec = [];
    while(vec.length &lt; n)
        vec.push(lower + (upper-lower) * Math.random());
    return vec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

m.randMat = function(row,col,lower,upper) {
lower = (typeof lower !== 'undefined') ? lower : 0;
upper = (typeof upper !== 'undefined') ? upper : 1;
var mat = [];
while(mat.length &lt; row)
    mat.push(m.<span class="apidocCodeKeywordSpan">randVec</span>(col,lower,upper));
return mat;
};

m.randnVec = function(n,mean,sigma) {
var vec = [];
while(vec.length &lt; n)
    vec.push(mean+sigma* m.randn());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.randn" id="apidoc.element.machine_learning.math.randn">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>randn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randn = function () {
    // generate random guassian distribution number. (mean : 0, standard deviation : 1)
    var v1, v2, s;

    do {
        v1 = 2 * Math.random() - 1;   // -1.0 ~ 1.0 ê¹Œì§€ì˜ ê°’
        v2 = 2 * Math.random() - 1;   // -1.0 ~ 1.0 ê¹Œì§€ì˜ ê°’
        s = v1 * v1 + v2 * v2;
    } while (s &gt;= 1 || s == 0);

    s = Math.sqrt( (-2 * Math.log(s)) / s );
    return v1 * s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    mat.push(m.randVec(col,lower,upper));
return mat;
};

m.randnVec = function(n,mean,sigma) {
var vec = [];
while(vec.length &lt; n)
    vec.push(mean+sigma* m.<span class="apidocCodeKeywordSpan">randn</span>());
return vec;
};

m.randnMat = function(row,col,mean,sigma) {
var mat = [];
while(mat.length &lt; row)
    mat.push(m.randnVec(col,mean,sigma));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.randnMat" id="apidoc.element.machine_learning.math.randnMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>randnMat
        <span class="apidocSignatureSpan">(row, col, mean, sigma)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randnMat = function (row, col, mean, sigma) {
    var mat = [];
    while(mat.length &lt; row)
        mat.push(m.randnVec(col,mean,sigma));
    return mat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.randnVec" id="apidoc.element.machine_learning.math.randnVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>randnVec
        <span class="apidocSignatureSpan">(n, mean, sigma)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randnVec = function (n, mean, sigma) {
    var vec = [];
    while(vec.length &lt; n)
        vec.push(mean+sigma* m.randn());
    return vec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    vec.push(mean+sigma* m.randn());
return vec;
};

m.randnMat = function(row,col,mean,sigma) {
var mat = [];
while(mat.length &lt; row)
    mat.push(m.<span class="apidocCodeKeywordSpan">randnVec</span>(col,mean,sigma));
return mat;
};

m.identity = function (n) {
var result = new Array(n);

for (var i = 0; i &lt; n ; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.range" id="apidoc.element.machine_learning.math.range">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>range
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">range = function (start, end, step) {
    var ret = [];
    if(typeof step === "undefined")
        step = 1;
    if(typeof end === "undefined") {
        end = start;
        start = 0;
    }
    for(var i=start;i&lt;end;i+=step)
        ret.push(i);
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    means : means
};
}

var getRandomMeans = function(data,k, init_using_data) {
var clusters = [];
if(init_using_data) {
    var cluster_index = math.<span class="apidocCodeKeywordSpan">range</span>(data.length);
    cluster_index = math.shuffle(cluster_index);
    for(i=0 ; i&lt;k ; i++) {
        clusters.push(data[cluster_index[i]]);
    }
} else {
    var i,j;
    var ranges = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.shape" id="apidoc.element.machine_learning.math.shape">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>shape
        <span class="apidocSignatureSpan">(mat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shape = function (mat) {
    var row = mat.length;
    var col = mat[0].length;
    return [row,col];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return result;
} else {
    throw new Error("Length Error : not same.")
}
};

m.addMatScalar = function(mat,scalar) {
var row = m.<span class="apidocCodeKeywordSpan">shape</span>(mat)[0];
var col = m.shape(mat)[1];
var i , j,result = [];
for(i=0 ; i&lt;row ; i++) {
    var rowVec = [];
    for(j=0 ; j&lt;col ; j++) {
        rowVec.push(mat[i][j] + scalar);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.shuffle" id="apidoc.element.machine_learning.math.shuffle">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>shuffle
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shuffle = function (arr){
    var o = [];
    for(var i=0;i&lt;arr.length;i++)
        o.push(arr[i]); // deep copy
    for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
    return o;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
}

var getRandomMeans = function(data,k, init_using_data) {
var clusters = [];
if(init_using_data) {
    var cluster_index = math.range(data.length);
    cluster_index = math.<span class="apidocCodeKeywordSpan">shuffle</span>(cluster_index);
    for(i=0 ; i&lt;k ; i++) {
        clusters.push(data[cluster_index[i]]);
    }
} else {
    var i,j;
    var ranges = [];
    for(i=0 ; i&lt;data[0].length ; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.sigmoid" id="apidoc.element.machine_learning.math.sigmoid">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>sigmoid
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sigmoid = function (x) {
    var sigmoid = (1. / (1 + Math.exp(-x)))
    if(sigmoid ==1) {
     //   console.warn("Something Wrong!! Sigmoid Function returns 1. Probably javascript float precision problem?\nSlightly Controlled
 value to 1 - 1e-14")
        sigmoid = 0.99999999999999; // Javascript Float Precision Problem.. This is a limit of javascript.
    } else if(sigmoid ==0) {
      //  console.warn("Something Wrong!! Sigmoid Function returns 0. Probably javascript float precision problem?\nSlightly Controlled
 value to 1e-14")
        sigmoid = 1e-14;
    }
    return sigmoid; // sigmoid cannot be 0 or 1;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //  console.warn("Something Wrong!! Sigmoid Function returns 0. Probably javascript float precision problem?\nSlightly Controlled
 value to 1e-14")
    sigmoid = 1e-14;
}
return sigmoid; // sigmoid cannot be 0 or 1;;
};

m.dSigmoid = function(x){
a = m.<span class="apidocCodeKeywordSpan">sigmoid</span>(x);
return a * (1. - a);
};

m.probToBinaryMat = function(mat) {
var row = m.shape(mat)[0];
var col = m.shape(mat)[1];
var i,j;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.softmaxMat" id="apidoc.element.machine_learning.math.softmaxMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>softmaxMat
        <span class="apidocSignatureSpan">(mat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">softmaxMat = function (mat) {
    var result=[], i;
    for(i=0 ; i&lt;mat.length ; i++)
        result.push(m.softmaxVec(mat[i]));
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(typeof settings['lr'] !== 'undefined')
lr = settings['lr'];
    if(typeof settings['epochs'] !== 'undefined')
epochs = settings['epochs'];
    var i;
    var currentProgress = 1;
    for(i=0;i&lt;epochs;i++) {
var probYgivenX = math.<span class="apidocCodeKeywordSpan">softmaxMat</span>(math.addMatVec(math.mulMat(self.x,self.W),self.b));
var deltaY = math.minusMat(self.y,probYgivenX);

var deltaW = math.mulMat(math.transpose(self.x),deltaY);
var deltaB = math.meanMatAxis(deltaY,0);

self.W = math.addMat(self.W,math.mulMatScalar(deltaW,lr));
self.b = math.addVec(self.b,math.mulVecScalar(deltaB,lr));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.softmaxVec" id="apidoc.element.machine_learning.math.softmaxVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>softmaxVec
        <span class="apidocSignatureSpan">(vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">softmaxVec = function (vec) {
    var max = m.maxVec(vec);
    var preSoftmaxVec = m.activateVec(vec,function(x) {return Math.exp(x - max);})
    return m.activateVec(preSoftmaxVec,function(x) {return x/ m.sumVec(preSoftmaxVec)})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var preSoftmaxVec = m.activateVec(vec,function(x) {return Math.exp(x - max);})
    return m.activateVec(preSoftmaxVec,function(x) {return x/ m.sumVec(preSoftmaxVec)})
};

m.softmaxMat = function(mat) {
    var result=[], i;
    for(i=0 ; i&lt;mat.length ; i++)
        result.push(m.<span class="apidocCodeKeywordSpan">softmaxVec</span>(mat[i]));
    return result;
};

m.randInt = function(min,max) {
  var rand = Math.random() * (max - min + 0.9999) + min
  return Math.floor(rand);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.squareMat" id="apidoc.element.machine_learning.math.squareMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>squareMat
        <span class="apidocSignatureSpan">(mat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">squareMat = function (mat) {
    var squareMat = [];
    var i;
    for(i=0;i&lt;mat.length;i++) {
        squareMat.push(m.squareVec(mat[i]));
    }
    return squareMat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.squareVec" id="apidoc.element.machine_learning.math.squareVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>squareVec
        <span class="apidocSignatureSpan">(vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">squareVec = function (vec) {
    var squareVec = [];
    var i;
    for(i=0;i&lt;vec.length;i++) {
        squareVec.push(vec[i]*vec[i]);
    }
    return squareVec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return squareVec;
};

m.squareMat = function(mat) {
var squareMat = [];
var i;
for(i=0;i&lt;mat.length;i++) {
    squareMat.push(m.<span class="apidocCodeKeywordSpan">squareVec</span>(mat[i]));
}
return squareMat;
};

m.minVec = function(vec) {
var min = vec[0];
var i = vec.length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.sumMat" id="apidoc.element.machine_learning.math.sumMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>sumMat
        <span class="apidocSignatureSpan">(mat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sumMat = function (mat) {
    var sum = 0;
    var i = mat.length;
    while (i--) {
        for(var j=0;j&lt;mat[0].length;j++)
          sum += mat[i][j];
    }
    return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
m.meanVec = function(vec) {
return 1. * m.sumVec(vec) / vec.length;
};

m.meanMat = function(mat) {
var row = mat.length;
var col = mat[0].length;
return 1. * m.<span class="apidocCodeKeywordSpan">sumMat</span>(mat) / (row * col);
};

m.meanMatAxis = function(mat,axis) {
// default axis 0;
// axis 0 : mean of col vector . axis 1 : mean of row vector
if(axis === 1) {
    var row = m.shape(mat)[0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.sumMatAxis" id="apidoc.element.machine_learning.math.sumMatAxis">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>sumMatAxis
        <span class="apidocSignatureSpan">(mat, axis)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sumMatAxis = function (mat, axis) {
    // default axis 0;
    // axis 0 : mean of col vector . axis 1 : mean of row vector
    if(axis === 1) {
        var row = m.shape(mat)[0];
        var i ;
        var result = [];
        for(i=0 ; i&lt;row; i++)
            result.push(m.sumVec(mat[i]));
        return result;
    } else {
        mat_T = m.transpose(mat);
        return m.sumMatAxis(mat_T,1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

LogisticRegression.prototype.getReconstructionCrossEntropy = function () {
    var self = this;
    var probYgivenX = math.softmaxMat(math.addMatVec(math.mulMat(self.x,self.W),self.b));
    var a = math.mulMatElementWise(self.y, math.activateMat(probYgivenX,Math.log));
    var b = math.mulMatElementWise(math.mulMatScalar(math.addMatScalar(self.y,-1),-1),
        math.activateMat(math.mulMatScalar(math.addMatScalar(probYgivenX,-1),-1),Math.log));
    var crossEntropy = -math.meanVec(math.<span class="apidocCodeKeywordSpan">sumMatAxis</span>(math.addMat(a,b),1));
    return crossEntropy;
};

LogisticRegression.prototype.predict = function (x) {
    var self = this;
    return math.softmaxMat(math.addMatVec(math.mulMat(x,self.W),self.b));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.sumVec" id="apidoc.element.machine_learning.math.sumVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>sumVec
        <span class="apidocSignatureSpan">(vec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sumVec = function (vec) {
    var sum = 0;
    var i = vec.length;
    while (i--) {
        sum += vec[i];
    }
    return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // default axis 0;
    // axis 0 : mean of col vector . axis 1 : mean of row vector
    if(axis === 1) {
        var row = m.shape(mat)[0];
        var i ;
        var result = [];
        for(i=0 ; i&lt;row; i++)
            result.push(m.<span class="apidocCodeKeywordSpan">sumVec</span>(mat[i]));
        return result;
    } else {
        mat_T = m.transpose(mat);
        return m.sumMatAxis(mat_T,1);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.transpose" id="apidoc.element.machine_learning.math.transpose">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>transpose
        <span class="apidocSignatureSpan">(mat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transpose = function (mat) {
    var result = new Array(mat[0].length);
    for (var i = 0; i &lt; mat[0].length; i++) {
        result[i] = new Array(mat.length);
        for (var j = 0; j &lt; mat.length; j++) {
            result[i][j] = mat[j][i];
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

HiddenLayer.prototype.backPropagate = function (input) { // example+num * n_out matrix
var self = this;
if(typeof input === 'undefined')
    throw new Error("No BackPropagation Input.")

var linearOutput = math.mulMat(input, math.<span class="apidocCodeKeywordSpan">transpose</span>(self.W));
return linearOutput;
}

HiddenLayer.prototype.sampleHgivenV = function(input) {
var self = this;
if(typeof input !== 'undefined')
    self.input = input;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.zeroMat" id="apidoc.element.machine_learning.math.zeroMat">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>zeroMat
        <span class="apidocSignatureSpan">(row, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zeroMat = function (row, col) {
    var mat = [];
    while(mat.length &lt; row)
        mat.push(m.zeroVec(col));
    return mat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Created by joonkukang on 2014. 1. 12..
 */
var math = require('./utils').math;
let LogisticRegression = module.exports = function (settings) {
    var self = this;
    self.x = settings['input'];
    self.y = settings['label'];
    self.W = math.<span class="apidocCodeKeywordSpan">zeroMat</span>(settings['n_in'],settings['n_out']);
    self.b = math.zeroVec(settings['n_out']);
    self.settings = {
        'log level' : 1 // 0 : nothing, 1 : info, 2: warn
    };
};

LogisticRegression.prototype.train = function (settings) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.math.zeroVec" id="apidoc.element.machine_learning.math.zeroVec">
        function <span class="apidocSignatureSpan">machine_learning.math.</span>zeroVec
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zeroVec = function (n) {
    var vec = [];
    while(vec.length &lt; n)
        vec.push(0);
    return vec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.input = settings['input'];

    if(typeof settings['W'] === 'undefined') {
        var a = 1. / settings['n_in'];
        settings['W'] = math.randMat(settings['n_in'],settings['n_out'],-a,a);
    }
    if(typeof settings['b'] === 'undefined')
        settings['b'] = math.<span class="apidocCodeKeywordSpan">zeroVec</span>(settings['n_out']);
    if(typeof settings['activation'] === 'undefined')
        settings['activation'] = math.sigmoid;

    self.W = settings['W'];
    self.b = settings['b'];
    self.activation = settings['activation'];
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.nmf" id="apidoc.module.machine_learning.nmf">module machine_learning.nmf</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.nmf.factorize" id="apidoc.element.machine_learning.nmf.factorize">
        function <span class="apidocSignatureSpan">machine_learning.nmf.</span>factorize
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factorize = function (options) {
    var fc = options['features'];
    var matrix = options['matrix'];
    var epochs = options['epochs'];
    var row = math.shape(matrix)[0], col = math.shape(matrix)[1];
    var a = math.randMat(row,fc,0,1);
    var b = math.randMat(fc,col,0,1);

    var i;
    for(i=0 ; i&lt;epochs; i++) {
        var ab = math.mulMat(a,b)
      //  cost = difcost(ab,matrix);
      //  if(i % 10 ==0) console.log("cost ",cost);
      //  if(cost == 0) break;
        var bn = math.mulMat(math.transpose(a),matrix);
        var bd = math.mulMat(math.mulMat(math.transpose(a),a),b);

        b = math.activateTwoMat(math.mulMatElementWise(b,bn),bd,function(x,y){return x/y});

        var an = math.mulMat(matrix, math.transpose(b));
        var ad = math.mulMat(math.mulMat(a,b), math.transpose(b));

        a = math.activateTwoMat(math.mulMatElementWise(a,an),ad,function(x,y){return x/y});
    }
    return [a,b];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## NMF (Non-negative matrix factorization)
```javascript
var ml = require('machine_learning');
var matrix = [[22,28],
              [49,64]];

var result = ml.nmf.<span class="apidocCodeKeywordSpan">factorize</span>({
    matrix : matrix,
    features : 3,
    epochs : 100
});

console.log("First Matrix : ",result[0]);
console.log("Second Matrix : ",result[1]);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.optimize" id="apidoc.module.machine_learning.optimize">module machine_learning.optimize</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.optimize.anneal" id="apidoc.element.machine_learning.optimize.anneal">
        function <span class="apidocSignatureSpan">machine_learning.optimize.</span>anneal
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anneal = function (options){
    var domain = options['domain'];
    var costf = options['costf'];
    var temperature = options['temperature'];
    var cool = options['cool'];
    var step = options['step'];
    var callback

    var i;
    var vec = [];
    for(i=0 ; i&lt;domain.length ; i++)
        vec.push(math.randInt(domain[i][0],domain[i][1]));

    while(temperature &gt; 0.1) {
        var idx = math.randInt(0,domain.length - 1);
        var dir = math.randInt(-step,step);
        var newVec = [];
        for(i=0; i&lt;vec.length ; i++)
            newVec.push(vec[i]);
        newVec[idx]+=dir;
        if(newVec[idx] &lt; domain[idx][0]) newVec[idx] = domain[idx][0];
        if(newVec[idx] &gt; domain[idx][1]) newVec[idx] = domain[idx][1];

        var ea = costf(vec);
        var eb = costf(newVec);
        var p = Math.exp(-1.*(eb-ea)/temperature);
        if(eb &lt; ea || Math.random() &lt; p)
            vec = newVec;

        temperature *= cool;
    }

    return vec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return cost;
};

var domain = [];
for(var i=0;i&lt;15;i++)
    domain.push([1,70]); // domain[idx][0] : minimum of vec[idx], domain[idx][1] : maximum of vec[idx].

var vec = ml.optimize.<span class="apidocCodeKeywordSpan">anneal</span>({
    domain : domain,
    costf : costf,
    temperature : 100000.0,
    cool : 0.999,
    step : 4
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.optimize.genetic" id="apidoc.element.machine_learning.optimize.genetic">
        function <span class="apidocSignatureSpan">machine_learning.optimize.</span>genetic
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">genetic = function (options){
    var domain = options['domain'];
    var costf = options['costf'];
    var population = options['population'];
    var q = options['q'] || 0.3;
    var elite = options['elite'] || population * 0.04;
    var epochs = options['epochs'] || 100;

    var i,j;
    // Initialize population array
    var pop =[];
    for(i=0; i&lt;population; i++) {
        var vec = [];
        for(j=0; j&lt;domain.length; j++)
            vec.push(math.randInt(domain[j][0],domain[j][1]));
        pop.push(vec);
    }
    pop.sort(function(a,b){return costf(a) - costf(b);});

    for(i=0 ; i&lt;epochs ; i++) {
        // elitism
        var newPop = [];
        for(j=0;j&lt;elite;j++)
            newPop.push(pop[j]);

        // compute fitnesses
        var fitnesses = [];
        for(j=0; j&lt;pop.length; j++)
            fitnesses[j] = q * Math.pow(1-q,j);
        fitnesses = math.normalizeVec(fitnesses);

        // crossover, mutate
        for(j=0; j&lt;pop.length - elite;j++) {
            var idx1 = rouletteWheel(fitnesses);
            var idx2 = rouletteWheel(fitnesses);
            var crossovered = crossover(pop[idx1],pop[idx2]);
            var mutated = mutate(crossovered);
            newPop.push(mutated);
        }

        // replacement
        pop = newPop;
        pop.sort(function(a,b){return costf(a) - costf(b);});
       //console.log("Current Cost : ",costf(pop[0]));
    }
    return pop[0];

    function mutate(vec) {
        var idx = math.randInt(0,domain.length - 1);
        var newVec = [];
        var i;
        for(i=0; i&lt;domain.length ; i++)
            newVec.push(vec[i]);
        newVec[idx] += (Math.random() &lt; 0.5) ? 1 : -1;
        if(newVec[idx] &lt; domain[idx][0]) newVec[idx] = domain[idx][0];
        if(newVec[idx] &gt; domain[idx][1]) newVec[idx] = domain[idx][1];
        return newVec;
    }
    function crossover(vec1,vec2) {
        var idx = math.randInt(0,domain.length - 2);
        var newVec = [];
        var i;
        for(i=0; i&lt;idx ; i++)
            newVec.push(vec1[i]);
        for(i=idx; i&lt;domain.length; i++)
            newVec.push(vec2[i]);
        return newVec;
    }
    function rouletteWheel(vec) {
        var a = [0.0];
        var i;
        for(i=0;i&lt;vec.length;i++) {
            a.push(a[i] + vec[i]);
        }
        var rand = Math.random();
        for(i=0;i&lt; a.length;i++) {
            if(rand &gt; a[i] &amp;&amp; rand &lt;= a[i+1])
                return i;
        }
        return -1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return cost;
};

var domain = [];
for(var i=0;i&lt;15;i++)
domain.push([1,70]); // domain[idx][0] : minimum of vec[idx], domain[idx][1] : maximum of vec[idx].

var vec = ml.optimize.<span class="apidocCodeKeywordSpan">genetic</span>({
domain : domain,
costf : costf,
population : 50,
elite : 2, // elitism. number of elite chromosomes.
epochs : 300,
q : 0.3 // Rank-Based Fitness Assignment. fitness = q * (1-q)^(rank-1)
        // higher q --&gt; higher selection pressure
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.machine_learning.optimize.hillclimb" id="apidoc.element.machine_learning.optimize.hillclimb">
        function <span class="apidocSignatureSpan">machine_learning.optimize.</span>hillclimb
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hillclimb = function (options){
    var domain = options['domain'];
    var costf = options['costf'];

    var i;
    var vec = [];
    for(i=0 ; i&lt;domain.length ; i++)
        vec.push(math.randInt(domain[i][0],domain[i][1]));

    var current, best;

    while(true) {
        var neighbors = [];
        var i,j;

        for(i=0 ; i&lt;domain.length ; i++) {
            if(vec[i] &gt; domain[i][0]) {
                var newVec = [];
                for(j=0 ; j&lt;domain.length ; j++)
                    newVec.push(vec[j]);
                newVec[i]-=1;
                neighbors.push(newVec);
            } else if (vec[i] &lt; domain[i][1]) {
                var newVec = [];
                for(j=0 ; j&lt;domain.length ; j++)
                    newVec.push(vec[j]);
                newVec[i]+=1;
                neighbors.push(newVec);
            }
        }

        current = costf(vec);
        best = current;
        for(i=0 ; i&lt;neighbors.length ; i++) {
            var cost = costf(neighbors[i]);
            if(cost &lt; best) {
                best = cost;
                vec = neighbors[i];
            }
        }
        if(best === current)
            break;
    }
    return vec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return cost;
};

var domain = [];
for(var i=0;i&lt;15;i++)
    domain.push([1,70]); // domain[idx][0] : minimum of vec[idx], domain[idx][1] : maximum of vec[idx].

var vec = ml.optimize.<span class="apidocCodeKeywordSpan">hillclimb</span>({
    domain : domain,
    costf : costf
});

console.log("vec : ",vec);
console.log("cost : ",costf(vec));
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.machine_learning.utils" id="apidoc.module.machine_learning.utils">module machine_learning.utils</a></h1>


    <h2>
        <a href="#apidoc.element.machine_learning.utils.isNumber" id="apidoc.element.machine_learning.utils.isNumber">
        function <span class="apidocSignatureSpan">machine_learning.utils.</span>isNumber
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNumber = function (n) {
    return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function classify(observaton,tree) {
if(typeof tree.results !== 'undefined')
    return tree.results;
else {
    var v = observaton[tree.col];
    var branch;
    if(utils.<span class="apidocCodeKeywordSpan">isNumber</span>(v)) {
        if(v&gt;=tree.value) branch = tree.tb;
        else branch = tree.fb;
    } else {
        if(v === tree.value) branch = tree.tb;
        else branch = tree.fb;
    }
    return classify(observaton,branch);
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>